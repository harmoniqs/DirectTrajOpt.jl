export NonlinearKnotPointConstraint

using ..Constraints

# ----------------------------------------------------------------------------- #
# NonlinearKnotPointConstraint
# ----------------------------------------------------------------------------- #

"""
    NonlinearKnotPointConstraint{F, F2, F3} <: AbstractNonlinearConstraint

Constraint applied at individual knot points over a trajectory.

Similar to TrajectoryDynamics, this struct stores the constraint function, evaluation methods,
and pre-allocated storage for efficient repeated evaluations.

# Fields
- `g::F`: Constraint function mapping (variables..., params) -> constraint values
- `var_names::Vector{Symbol}`: Names of trajectory variables the constraint depends on
- `equality::Bool`: If true, g(x) = 0; if false, g(x) ≤ 0
- `times::Vector{Int}`: Time indices where constraint is applied
- `params::Vector`: Parameters for each time index (e.g., time-varying targets)
- `g_dim::Int`: Dimension of constraint output at each time step
- `dim::Int`: Total constraint dimension (g_dim * length(times))
- `∂g!::F2`: In-place function computing Jacobians across all timesteps
- `∂gs::Vector{SparseMatrixCSC{Float64, Int}}`: Pre-allocated Jacobian storage
- `μ∂²g!::F3`: In-place function computing weighted Hessians across all timesteps
- `μ∂²gs::Vector{SparseMatrixCSC{Float64, Int}}`: Pre-allocated Hessian storage
"""
struct NonlinearKnotPointConstraint{F, F2, F3} <: AbstractNonlinearConstraint
    g::F
    var_names::Vector{Symbol}
    equality::Bool
    times::Vector{Int}
    params::Vector
    g_dim::Int
    dim::Int
    ∂g!::F2
    ∂gs::Vector{SparseMatrixCSC{Float64, Int}}
    μ∂²g!::F3
    μ∂²gs::Vector{SparseMatrixCSC{Float64, Int}}

    """
        NonlinearKnotPointConstraint(
            g::Function,
            names::Union{Symbol, AbstractVector{Symbol}},
            traj::NamedTrajectory;
            kwargs...
        )

    Create a NonlinearKnotPointConstraint object that represents a nonlinear constraint on a trajectory.

    # Arguments
    - `g::Function`: Function over knot point variable(s) that defines the constraint. 
      - For single variable: `g(x)` where `x` is the variable values at a knot point
      - For multiple variables: `g(x, u)` where each argument corresponds to a variable in `names`
    - `names::Union{Symbol, AbstractVector{Symbol}}`: Name(s) of the variable(s) to be constrained.
      - Single variable: `:x`
      - Multiple variables: `[:x, :u]`
    - `traj::NamedTrajectory`: The trajectory on which the constraint is defined.

    # Keyword Arguments
    - `equality::Bool=true`: If `true`, the constraint is `g(x) = 0`. Otherwise, the constraint is `g(x) ≤ 0`.
    - `times::AbstractVector{Int}=1:traj.N`: Time indices at which the constraint is enforced.
    - `params::AbstractVector=fill(nothing, length(times))`: Parameters for each time step (e.g., time-varying targets).

    # Examples
    ```julia
    # Single variable constraint
    constraint = NonlinearKnotPointConstraint(
        x -> [x[1]^2 + x[2]^2 - 1],
        :x, traj
    )

    # Multiple variable constraint
    constraint = NonlinearKnotPointConstraint(
        (x, u) -> [x[1] - u[1]^2],
        [:x, :u], traj
    )
    ```
    """
    function NonlinearKnotPointConstraint(
        g::Function,
        names::AbstractVector{Symbol},
        traj::NamedTrajectory,
        params::AbstractVector;
        equality::Bool=true,
        times::AbstractVector{Int}=1:traj.N,
    )
        @assert length(params) == length(times) "params must have the same length as times"

        # Get component indices for all variables
        x_comps = vcat([traj.components[name] for name in names]...)

        # Determine constraint dimension by evaluating with first parameter
        Z⃗ = vec(traj)
        x_slice_test = slice(1, x_comps, traj.dim)
        @assert g(Z⃗[x_slice_test], params[1]) isa AbstractVector{<:Real}
        g_dim = length(g(Z⃗[x_slice_test], params[1]))

        # Create sparsity structures
        ∂g_structure = jacobian_structure_single(names, traj)
        ∂gs = [copy(∂g_structure) for _ in times]

        μ∂²g_structure = hessian_structure_single(names, traj)
        μ∂²gs = [copy(μ∂²g_structure) for _ in times]

        # Create wrapper functions - they will capture g, names, times, params through closure
        @views function ∂g!(
            ∂gs::Vector{SparseMatrixCSC{Float64, Int}},
            Z⃗::AbstractVector
        )
            # Wrap datavector in NamedTrajectory to access KnotPoints
            Z_traj = NamedTrajectory(traj; datavec=Z⃗)
            for (i, t) ∈ enumerate(times)
                zₖ = Z_traj[t]
                # Extract relevant variables
                x_vals = vcat([zₖ[name] for name in names]...)
                x_comps = vcat([zₖ.components[name] for name in names]...)
                
                # Compute Jacobian
                ∂g_local = zeros(g_dim, length(x_vals))
                ForwardDiff.jacobian!(
                    ∂g_local,
                    x -> g(x, params[i]),
                    x_vals
                )
                
                # Map to full structure
                fill!(∂gs[i], 0.0)
                ∂gs[i][:, x_comps] = ∂g_local
            end
            return nothing
        end

        @views function μ∂²g!(
            μ∂²gs::Vector{SparseMatrixCSC{Float64, Int}},
            Z⃗::AbstractVector,
            μ⃗::AbstractVector
        )
            # Wrap datavector in NamedTrajectory to access KnotPoints
            Z_traj = NamedTrajectory(traj; datavec=Z⃗)
            for (i, t) ∈ enumerate(times)
                zₖ = Z_traj[t]
                μₖ = μ⃗[slice(i, g_dim)]
                
                # Extract relevant variables
                x_vals = vcat([zₖ[name] for name in names]...)
                x_comps = vcat([zₖ.components[name] for name in names]...)
                
                # Compute Hessian
                μ∂²g_local = zeros(length(x_vals), length(x_vals))
                ForwardDiff.hessian!(
                    μ∂²g_local,
                    x -> μₖ' * g(x, params[i]),
                    x_vals
                )
                
                # Map to full structure
                fill!(μ∂²gs[i], 0.0)
                μ∂²gs[i][x_comps, x_comps] = μ∂²g_local
            end
            return nothing
        end

        return new{typeof(g), typeof(∂g!), typeof(μ∂²g!)}(
            g,
            names,
            equality,
            times,
            params,
            g_dim,
            g_dim * length(times),
            ∂g!,
            ∂gs,
            μ∂²g!,
            μ∂²gs
        )
    end
end

# Helper functions for structure (moved outside struct)
function jacobian_structure_single(names::Vector{Symbol}, traj::NamedTrajectory)
    x_comps = vcat([traj.components[name] for name in names]...)
    ∂g = spzeros(traj.dim, traj.dim)
    ∂g[:, x_comps] .= 1.0
    return ∂g
end

function hessian_structure_single(names::Vector{Symbol}, traj::NamedTrajectory)
    x_comps = vcat([traj.components[name] for name in names]...)
    μ∂²g = spzeros(traj.dim, traj.dim)
    μ∂²g[x_comps, x_comps] .= 1.0
    return μ∂²g
end

# Convenience constructor without params - creates wrapper that ignores param argument
function NonlinearKnotPointConstraint(
    g::Function,
    names::AbstractVector{Symbol},
    traj::NamedTrajectory;
    times::AbstractVector{Int}=1:traj.N,
    kwargs...
)
    num_vars = length(names)
    
    if num_vars == 1
        # Single variable: g(x) where x is the variable values
        params = [nothing for _ in times]
        g_param = (x, _) -> g(x)
        return NonlinearKnotPointConstraint(
            g_param, 
            names, 
            traj, 
            params; 
            times=times, 
            kwargs...
        )
    else
        # Multiple variables: determine if g expects separate arguments or concatenated
        
        # Get component ranges for splitting concatenated vector
        comp_ranges = Vector{UnitRange{Int}}(undef, num_vars)
        offset = 0
        for (i, name) in enumerate(names)
            comp_len = length(traj.components[name])
            comp_ranges[i] = (offset + 1):(offset + comp_len)
            offset += comp_len
        end
        
        params = [nothing for _ in times]
        
        # Test if g accepts separate arguments
        Z⃗ = vec(traj)
        x_comps = vcat([traj.components[name] for name in names]...)
        x_slice = slice(1, x_comps, traj.dim)
        test_vec = Z⃗[x_slice]
        test_args = [test_vec[r] for r in comp_ranges]
        
        accepts_separate_args = false
        try
            result = g(test_args...)
            accepts_separate_args = result isa AbstractVector
        catch
            accepts_separate_args = false
        end
        
        if accepts_separate_args
            # Wrapper that splits concatenated vector into separate arguments
            g_param = function(x_concat, _)
                args = [x_concat[r] for r in comp_ranges]
                return g(args...)
            end
        else
            # g expects a single concatenated vector
            g_param = (x, _) -> g(x)
        end
        
        return NonlinearKnotPointConstraint(
            g_param, 
            names, 
            traj, 
            params; 
            times=times, 
            kwargs...
        )
    end
end

function NonlinearKnotPointConstraint(g::Function, name::Symbol, traj::NamedTrajectory; kwargs...)
    return NonlinearKnotPointConstraint(g, [name], traj; kwargs...)
end

# ----------------------------------------------------------------------------- #
# Method Implementations for NonlinearKnotPointConstraint
# ----------------------------------------------------------------------------- #

"""
    (constraint::NonlinearKnotPointConstraint)(δ, zₖ::KnotPoint, k::Int)

Evaluate the constraint at a single knot point.
"""
function (constraint::NonlinearKnotPointConstraint)(
    δ::AbstractVector,
    zₖ::KnotPoint,
    k::Int
)
    # Extract the relevant variable values from the knot point
    x_vals = vcat([zₖ[name] for name in constraint.var_names]...)
    
    # Find which index this timestep corresponds to in constraint.times
    time_idx = findfirst(==(k), constraint.times)
    if isnothing(time_idx)
        error("Timestep $k not in constraint times $(constraint.times)")
    end
    
    δ[:] = constraint.g(x_vals, constraint.params[time_idx])
    return nothing
end

"""
    constraint_value(constraint::NonlinearKnotPointConstraint, traj::NamedTrajectory)

Evaluate the constraint at all specified time indices using the trajectory data.
"""
function Constraints.constraint_value(
    constraint::NonlinearKnotPointConstraint,
    traj::NamedTrajectory
)
    δ = zeros(constraint.dim)
    @views for (i, t) ∈ enumerate(constraint.times)
        # Extract the relevant variable values from the knot point
        x_vals = vcat([traj[t][name] for name in constraint.var_names]...)
        δ[slice(i, constraint.g_dim)] = constraint.g(x_vals, constraint.params[i])
    end
    
    return δ
end

"""
    jacobian_structure(constraint::NonlinearKnotPointConstraint, traj::NamedTrajectory)

Return the sparsity structure of a single knot point constraint Jacobian.
"""
function Constraints.jacobian_structure(
    constraint::NonlinearKnotPointConstraint, 
    traj::NamedTrajectory
)
    x_comps = vcat([traj.components[name] for name in constraint.var_names]...)
    
    ∂g = spzeros(constraint.g_dim, traj.dim)
    ∂g[:, x_comps] .= 1.0
    
    return ∂g
end

"""
    jacobian!(∂g, constraint::NonlinearKnotPointConstraint, zₖ::KnotPoint, k::Int)

Compute the Jacobian of the constraint at a single knot point.
"""
function Constraints.jacobian!(
    ∂g::AbstractMatrix,
    constraint::NonlinearKnotPointConstraint,
    zₖ::KnotPoint,
    k::Int
)
    # Extract the relevant variable values
    x_vals = vcat([zₖ[name] for name in constraint.var_names]...)
    
    # Find which index this timestep corresponds to in constraint.times
    time_idx = findfirst(==(k), constraint.times)
    if isnothing(time_idx)
        error("Timestep $k not in constraint times $(constraint.times)")
    end
    
    # Get component indices for the variables we're constraining
    x_comps = vcat([zₖ.components[name] for name in constraint.var_names]...)
    
    # Compute Jacobian with respect to the concatenated variables
    ∂g_local = zeros(constraint.g_dim, length(x_vals))
    ForwardDiff.jacobian!(
        ∂g_local,
        x -> constraint.g(x, constraint.params[time_idx]),
        x_vals
    )
    
    # Map to the full knot point Jacobian (g_dim × traj.dim)
    ∂g[:, x_comps] = ∂g_local
    
    return nothing
end

"""
    hessian_structure(constraint::NonlinearKnotPointConstraint, traj::NamedTrajectory)

Return the sparsity structure of a single knot point constraint Hessian.
"""
function Constraints.hessian_structure(
    constraint::NonlinearKnotPointConstraint,
    traj::NamedTrajectory
)
    x_comps = vcat([traj.components[name] for name in constraint.var_names]...)
    
    μ∂²g = spzeros(traj.dim, traj.dim)
    μ∂²g[x_comps, x_comps] .= 1.0
    
    return μ∂²g
end

"""
    hessian_of_lagrangian(constraint::NonlinearKnotPointConstraint, μₖ::AbstractVector, zₖ::KnotPoint, k::Int)

Compute the Hessian of the Lagrangian (μ'g) for the constraint at a single knot point.
"""
function Constraints.hessian_of_lagrangian(
    constraint::NonlinearKnotPointConstraint,
    μₖ::AbstractVector,
    zₖ::KnotPoint,
    k::Int
)
    # Extract the relevant variable values
    x_vals = vcat([zₖ[name] for name in constraint.var_names]...)
    
    # Find which index this timestep corresponds to in constraint.times
    time_idx = findfirst(==(k), constraint.times)
    if isnothing(time_idx)
        error("Timestep $k not in constraint times $(constraint.times)")
    end
    
    # Get component indices
    x_comps = vcat([zₖ.components[name] for name in constraint.var_names]...)
    
    # Compute Hessian with respect to the concatenated variables
    μ∂²g_local = zeros(length(x_vals), length(x_vals))
    ForwardDiff.hessian!(
        μ∂²g_local,
        x -> μₖ' * constraint.g(x, constraint.params[time_idx]),
        x_vals
    )
    
    # Map to the full knot point Hessian (traj.dim × traj.dim)
    μ∂²g = spzeros(zₖ.dim, zₖ.dim)
    μ∂²g[x_comps, x_comps] = μ∂²g_local
    
    return μ∂²g
end

# ----------------------------------------------------------------------------- #
# Legacy helper functions (for backward compatibility)
# ----------------------------------------------------------------------------- #

function get_full_jacobian(
    NLC::NonlinearKnotPointConstraint, 
    traj::NamedTrajectory
)
    Z_dim = traj.dim * traj.N + traj.global_dim
    ∂g_full = spzeros(NLC.dim, Z_dim)
    
    @views for (i, t) ∈ enumerate(NLC.times)
        # Use pre-computed Jacobian from storage
        # Rows: constraint equations for this timestep
        row_range = slice(i, NLC.g_dim)
        # Columns: trajectory components at timestep t
        col_range = slice(t, 1:traj.dim, traj.dim)
        ∂g_full[row_range, col_range] = NLC.∂gs[i]
    end
    
    return ∂g_full
end

function get_full_hessian(
    NLC::NonlinearKnotPointConstraint, 
    traj::NamedTrajectory
)
    Z_dim = traj.dim * traj.N + traj.global_dim
    μ∂²g_full = spzeros(Z_dim, Z_dim)
    
    @views for (i, t) ∈ enumerate(NLC.times)
        # Use pre-computed Hessian from storage (block diagonal structure)
        col_range = slice(t, 1:traj.dim, traj.dim)
        μ∂²g_full[col_range, col_range] = NLC.μ∂²gs[i]
    end
    
    return μ∂²g_full
end



# ============================================================================= #

@testitem "NonlinearKnotPointConstraint - single variable" begin

    using TrajectoryIndexingUtils
    
    include("../../test/test_utils.jl")

    _, traj = bilinear_dynamics_and_trajectory()

    g(a) = [norm(a) - 1.0]

    g_dim = 1
    times = 1:traj.N

    NLC = NonlinearKnotPointConstraint(g, :u, traj; times=times, equality=false)
    U_SLICE(k) = slice(k, traj.components[:u], traj.dim)

    ĝ(Z⃗) = vcat([g(Z⃗[U_SLICE(k)]) for k ∈ times]...)

    # Test constraint_value
    δ = Constraints.constraint_value(NLC, traj)
    @test δ ≈ ĝ(vec(traj))
    
    # Test jacobian!
    NLC.∂g!(NLC.∂gs, vec(traj))
    ∂g_full = Constraints.get_full_jacobian(NLC, traj)
    ∂g_autodiff = ForwardDiff.jacobian(ĝ, vec(traj))

    @test ∂g_full[:, 1:traj.dim * traj.N] ≈ ∂g_autodiff

    # Test hessian_of_lagrangian
    μ = randn(g_dim * traj.N)
    NLC.μ∂²g!(NLC.μ∂²gs, vec(traj), μ)
    μ∂²g_full = Constraints.get_full_hessian(NLC, traj)
    hessian_autodiff = ForwardDiff.hessian(Z -> μ'ĝ(Z), vec(traj))

    @test μ∂²g_full[1:traj.dim * traj.N, 1:traj.dim * traj.N] ≈ hessian_autodiff
end

@testitem "NonlinearKnotPointConstraint - single variable with vector syntax" begin

    using TrajectoryIndexingUtils
    
    include("../../test/test_utils.jl")

    _, traj = bilinear_dynamics_and_trajectory()

    # Test that [:x] syntax works the same as :x
    g(a) = [norm(a) - 1.0]

    g_dim = 1
    times = 1:traj.N

    NLC1 = NonlinearKnotPointConstraint(g, :u, traj; times=times, equality=false)
    NLC2 = NonlinearKnotPointConstraint(g, [:u], traj; times=times, equality=false)
    
    U_SLICE(k) = slice(k, traj.components[:u], traj.dim)
    ĝ(Z⃗) = vcat([g(Z⃗[U_SLICE(k)]) for k ∈ times]...)

    δ1 = Constraints.constraint_value(NLC1, vec(traj), traj)
    δ2 = Constraints.constraint_value(NLC2, vec(traj), traj)

    @test δ1 ≈ δ2
    @test δ1 ≈ ĝ(vec(traj))
end

@testitem "NonlinearKnotPointConstraint - multiple variables concatenated" begin

    using TrajectoryIndexingUtils
    
    include("../../test/test_utils.jl")

    _, traj = bilinear_dynamics_and_trajectory()

    # Constraint function that expects concatenated [x; u]
    g_concat(xu) = [xu[1]^2 + xu[2]^2 - 1.0, xu[3] - 0.5]

    g_dim = 2
    times = 1:traj.N

    NLC = NonlinearKnotPointConstraint(g_concat, [:x, :u], traj; times=times, equality=false)
    
    x_comps = vcat(traj.components[:x], traj.components[:u])
    XU_SLICE(k) = slice(k, x_comps, traj.dim)

    ĝ(Z⃗) = vcat([g_concat(Z⃗[XU_SLICE(k)]) for k ∈ times]...)

    # Test constraint_value
    δ = Constraints.constraint_value(NLC, vec(traj), traj)
    @test δ ≈ ĝ(vec(traj))
    
    # Test jacobian!
    Z_dim = traj.dim * traj.N + traj.global_dim
    ∂g_full = spzeros(NLC.dim, Z_dim)
    Constraints.jacobian!(∂g_full[:, 1:traj.dim * traj.N], NLC, vec(traj), traj)
    ∂g_autodiff = ForwardDiff.jacobian(ĝ, vec(traj))

    @test ∂g_full[:, 1:traj.dim * traj.N] ≈ ∂g_autodiff

    # Test hessian_of_lagrangian
    μ = randn(g_dim * traj.N)
    μ∂²g_full = Constraints.hessian_of_lagrangian(NLC, μ, vec(traj), traj)
    hessian_autodiff = ForwardDiff.hessian(Z -> μ'ĝ(Z), vec(traj))

    @test μ∂²g_full[1:traj.dim * traj.N, 1:traj.dim * traj.N] ≈ hessian_autodiff
end

@testitem "NonlinearKnotPointConstraint - multiple variables separate arguments" begin

    using TrajectoryIndexingUtils
    
    include("../../test/test_utils.jl")

    _, traj = bilinear_dynamics_and_trajectory()

    # Constraint function with SEPARATE arguments (nicer syntax!)
    g_separate(x, u) = [x[1]^2 + x[2]^2 - 1.0, u[1] - 0.5]

    g_dim = 2
    times = 1:traj.N

    # This should automatically detect and handle separate arguments
    NLC = NonlinearKnotPointConstraint(g_separate, [:x, :u], traj; times=times, equality=false)
    
    x_comps = vcat(traj.components[:x], traj.components[:u])
    XU_SLICE(k) = slice(k, x_comps, traj.dim)
    X_SLICE(k) = slice(k, traj.components[:x], traj.dim)
    U_SLICE(k) = slice(k, traj.components[:u], traj.dim)

    ĝ(Z⃗) = vcat([g_separate(Z⃗[X_SLICE(k)], Z⃗[U_SLICE(k)]) for k ∈ times]...)

    # Test constraint_value
    δ = Constraints.constraint_value(NLC, vec(traj), traj)
    @test δ ≈ ĝ(vec(traj))
    
    # Test jacobian!
    Z_dim = traj.dim * traj.N + traj.global_dim
    ∂g_full = spzeros(NLC.dim, Z_dim)
    Constraints.jacobian!(∂g_full[:, 1:traj.dim * traj.N], NLC, vec(traj), traj)
    ∂g_autodiff = ForwardDiff.jacobian(ĝ, vec(traj))

    @test ∂g_full[:, 1:traj.dim * traj.N] ≈ ∂g_autodiff

    # Test hessian_of_lagrangian
    μ = randn(g_dim * traj.N)
    μ∂²g_full = Constraints.hessian_of_lagrangian(NLC, μ, vec(traj), traj)
    hessian_autodiff = ForwardDiff.hessian(Z -> μ'ĝ(Z), vec(traj))

    @test μ∂²g_full[1:traj.dim * traj.N, 1:traj.dim * traj.N] ≈ hessian_autodiff
end

@testitem "NonlinearKnotPointConstraint - three variables separate arguments" begin

    using TrajectoryIndexingUtils
    using NamedTrajectories
    
    include("../../test/test_utils.jl")

    # Create trajectory with 3 variables
    N = 10
    x_dim = 2
    u_dim = 1
    a_dim = 1  # Additional variable
    Δt = 0.1
    
    traj = NamedTrajectory(
        (
            x = randn(x_dim, N),
            u = randn(u_dim, N),
            a = randn(a_dim, N),
            Δt = fill(Δt, N),
        );
        controls=(:u, :a),
        timestep=:Δt,
    )

    # Constraint with THREE separate arguments
    g_three(x, u, a) = [x[1] + u[1] + a[1] - 1.0, x[2]^2 - 0.5]

    g_dim = 2
    times = 1:traj.N

    NLC = NonlinearKnotPointConstraint(g_three, [:x, :u, :a], traj; times=times, equality=true)
    
    X_SLICE(k) = slice(k, traj.components[:x], traj.dim)
    U_SLICE(k) = slice(k, traj.components[:u], traj.dim)
    A_SLICE(k) = slice(k, traj.components[:a], traj.dim)

    ĝ(Z⃗) = vcat([g_three(Z⃗[X_SLICE(k)], Z⃗[U_SLICE(k)], Z⃗[A_SLICE(k)]) for k ∈ times]...)

    # Test constraint_value
    δ = Constraints.constraint_value(NLC, vec(traj), traj)
    @test δ ≈ ĝ(vec(traj))
    
    # Test jacobian!
    Z_dim = traj.dim * traj.N + traj.global_dim
    ∂g_full = spzeros(NLC.dim, Z_dim)
    Constraints.jacobian!(∂g_full[:, 1:traj.dim * traj.N], NLC, vec(traj), traj)
    ∂g_autodiff = ForwardDiff.jacobian(ĝ, vec(traj))

    @test ∂g_full[:, 1:traj.dim * traj.N] ≈ ∂g_autodiff

    # Test hessian_of_lagrangian
    μ = randn(g_dim * traj.N)
    μ∂²g_full = Constraints.hessian_of_lagrangian(NLC, μ, vec(traj), traj)
    hessian_autodiff = ForwardDiff.hessian(Z -> μ'ĝ(Z), vec(traj))

    @test μ∂²g_full[1:traj.dim * traj.N, 1:traj.dim * traj.N] ≈ hessian_autodiff
end

@testitem "NonlinearKnotPointConstraint - inequality vs equality" begin

    using TrajectoryIndexingUtils
    
    include("../../test/test_utils.jl")

    _, traj = bilinear_dynamics_and_trajectory()

    g(x, u) = [x[1] - u[1]]

    # Test inequality constraint
    NLC_ineq = NonlinearKnotPointConstraint(g, [:x, :u], traj; equality=false)
    @test NLC_ineq.equality == false

    # Test equality constraint (default)
    NLC_eq = NonlinearKnotPointConstraint(g, [:x, :u], traj)
    @test NLC_eq.equality == true

    # Both should compute same values, just interpreted differently
    δ_ineq = Constraints.constraint_value(NLC_ineq, vec(traj), traj)
    δ_eq = Constraints.constraint_value(NLC_eq, vec(traj), traj)
    
    @test δ_ineq ≈ δ_eq
end

@testitem "NonlinearKnotPointConstraint - subset of times" begin

    using TrajectoryIndexingUtils
    
    include("../../test/test_utils.jl")

    _, traj = bilinear_dynamics_and_trajectory()

    g(x) = [norm(x) - 1.0]
    
    # Only constrain first and last time steps
    times = [1, traj.N]
    
    NLC = NonlinearKnotPointConstraint(g, [:x], traj; times=times, equality=false)
    
    @test NLC.times == times
    @test NLC.dim == length(g(traj.x[:, 1])) * length(times)
    
    X_SLICE(k) = slice(k, traj.components[:x], traj.dim)
    ĝ(Z⃗) = vcat([g(Z⃗[X_SLICE(k)]) for k ∈ times]...)

    δ = Constraints.constraint_value(NLC, vec(traj), traj)

    @test δ ≈ ĝ(vec(traj))
end

