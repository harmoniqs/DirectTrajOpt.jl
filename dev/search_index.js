var documenterSearchIndex = {"docs":
[{"location":"generated/concepts/problem_formulation/#Problem-Formulation","page":"Problem Formulation","title":"Problem Formulation","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/#Overview","page":"Problem Formulation","title":"Overview","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"DirectTrajOpt.jl solves direct trajectory optimization problems using direct transcription, which converts continuous-time optimal control problems into finite-dimensional nonlinear programs (NLPs).","category":"page"},{"location":"generated/concepts/problem_formulation/#The-General-Form","page":"Problem Formulation","title":"The General Form","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"A trajectory optimization problem has the form:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"beginalign*\nundersetx_1N u_1Ntextminimize quad  J(x_1N u_1N) \ntextsubject to quad  f(x_k+1 x_k u_k Delta t t_k) = 0 quad k = 1 ldots N-1\n c_k(x_k u_k) geq 0 quad k = 1 ldots N \n x_1 = x_textinit quad x_N = x_textgoal \nendalign*","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Let's break down each component:","category":"page"},{"location":"generated/concepts/problem_formulation/#Decision-Variables","page":"Problem Formulation","title":"Decision Variables","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/#States:-x,-x,-...,-xₖ","page":"Problem Formulation","title":"States: x₁, x₂, ..., xₖ","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"The state represents the configuration of your system at each time step.","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"For a robot arm: joint angles and velocities\nFor a spacecraft: position and velocity\nFor a quantum system: state vector or unitary operator","category":"page"},{"location":"generated/concepts/problem_formulation/#Controls:-u,-u,-...,-uₖ","page":"Problem Formulation","title":"Controls: u₁, u₂, ..., uₖ","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"The control (or input) represents what you can actuate.","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"For a robot: motor torques\nFor a spacecraft: thruster forces\nFor quantum systems: electromagnetic field amplitudes","category":"page"},{"location":"generated/concepts/problem_formulation/#Time-Steps:-Δt,-Δt,-...,-Δtₖ","page":"Problem Formulation","title":"Time Steps: Δt₁, Δt₂, ..., Δtₖ","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"The time step can be:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Fixed: All Δt are equal and constant\nFree: Each Δt is a decision variable (for minimum time problems)","category":"page"},{"location":"generated/concepts/problem_formulation/#Cost-Function:-J(x,-u)","page":"Problem Formulation","title":"Cost Function: J(x, u)","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"The objective or cost function defines what you want to minimize. Common objectives include:","category":"page"},{"location":"generated/concepts/problem_formulation/#Control-Effort","page":"Problem Formulation","title":"Control Effort","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Minimize energy by penalizing large controls:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"J = sum_k=1^N u_k^2","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"using DirectTrajOpt\nusing NamedTrajectories\nusing LinearAlgebra","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Example:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"N = 10\ntraj = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt, controls=:u\n)\n\nobj_effort = QuadraticRegularizer(:u, traj, 1.0)","category":"page"},{"location":"generated/concepts/problem_formulation/#Minimum-Time","page":"Problem Formulation","title":"Minimum Time","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Minimize trajectory duration:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"J = sum_k=1^N Delta t_k","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"obj_time = MinimumTimeObjective(traj, 0.1)  # weight = 0.1","category":"page"},{"location":"generated/concepts/problem_formulation/#Terminal-Cost","page":"Problem Formulation","title":"Terminal Cost","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Penalize deviation from goal at final time:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"J = x_N - x_textgoal^2","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"x_goal = [1.0, 0.0]\nobj_terminal = TerminalObjective(x -> norm(x - x_goal)^2, :x, traj)","category":"page"},{"location":"generated/concepts/problem_formulation/#Combined-Objectives","page":"Problem Formulation","title":"Combined Objectives","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"You can add multiple objectives together:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"obj_combined = obj_effort + 0.1 * obj_time + 10.0 * obj_terminal","category":"page"},{"location":"generated/concepts/problem_formulation/#Dynamics-Constraints:-f(xₖ,-xₖ,-uₖ,-Δt,-t)-0","page":"Problem Formulation","title":"Dynamics Constraints: f(xₖ₊₁, xₖ, uₖ, Δt, t) = 0","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"The dynamics constraints ensure the trajectory obeys the system's equations of motion. These are encoded via integrators that discretize continuous dynamics.","category":"page"},{"location":"generated/concepts/problem_formulation/#Continuous-Dynamics","page":"Problem Formulation","title":"Continuous Dynamics","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"A continuous-time system has the form:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"dotx(t) = g(x(t) u(t) t)","category":"page"},{"location":"generated/concepts/problem_formulation/#Discrete-Approximation","page":"Problem Formulation","title":"Discrete Approximation","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Direct transcription approximates this using numerical integration:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"x_k+1 approx Phi(x_k u_k Delta t)","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"where Φ is an integration scheme (e.g., Euler, RK4, matrix exponential).","category":"page"},{"location":"generated/concepts/problem_formulation/#Example:-Bilinear-Dynamics","page":"Problem Formulation","title":"Example: Bilinear Dynamics","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"For control-linear systems:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"dotx = (G_0 + sum_i u_i G_i) x","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"The integrator uses matrix exponential:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"x_k+1 = exp(Delta t cdot G(u_k)) x_k","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"G_drift = [-0.1 1.0; -1.0 -0.1]\nG_drives = [[0.0 1.0; 1.0 0.0]]\nG = u -> G_drift + sum(u .* G_drives)\n\nintegrator = BilinearIntegrator(G, traj, :x, :u)","category":"page"},{"location":"generated/concepts/problem_formulation/#Path-Constraints:-c(x,-u)-0","page":"Problem Formulation","title":"Path Constraints: c(x, u) ≥ 0","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Path constraints restrict states and controls along the trajectory.","category":"page"},{"location":"generated/concepts/problem_formulation/#Bounds","page":"Problem Formulation","title":"Bounds","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Simple box constraints on variables:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"u_min leq u_k leq u_max","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"traj_bounded = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    bounds=(u = (-1.0, 1.0),)  # -1 ≤ u ≤ 1\n)","category":"page"},{"location":"generated/concepts/problem_formulation/#Nonlinear-Constraints","page":"Problem Formulation","title":"Nonlinear Constraints","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"More complex constraints (e.g., obstacle avoidance, no-go zones):","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Constraint: keep control magnitude bounded","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"constraint = NonlinearKnotPointConstraint(\n    u -> [1.0 - norm(u)],  # 1 - ||u|| ≥ 0  →  ||u|| ≤ 1\n    :u,\n    traj;\n    equality=false\n)","category":"page"},{"location":"generated/concepts/problem_formulation/#Boundary-Conditions","page":"Problem Formulation","title":"Boundary Conditions","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/#Initial-Condition:-x-x_init","page":"Problem Formulation","title":"Initial Condition: x₁ = x_init","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Fixes the starting state.","category":"page"},{"location":"generated/concepts/problem_formulation/#Final-Condition:-xₖ-x_goal","page":"Problem Formulation","title":"Final Condition: xₖ = x_goal","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Fixes the ending state (or penalizes deviation via terminal cost).","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"traj_bc = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = [0.0, 0.0],),  # Fixed initial state\n    final=(x = [1.0, 0.0],)     # Fixed final state\n)","category":"page"},{"location":"generated/concepts/problem_formulation/#Direct-Transcription","page":"Problem Formulation","title":"Direct Transcription","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/#Why-Direct-Transcription?","page":"Problem Formulation","title":"Why Direct Transcription?","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Mature solvers: Leverage powerful NLP solvers (Ipopt, SNOPT)\nConstraint handling: Natural way to include path constraints\nWarm starting: Can initialize with good guesses\nLarge problems: Scales well to thousands of variables","category":"page"},{"location":"generated/concepts/problem_formulation/#The-NLP-Formulation","page":"Problem Formulation","title":"The NLP Formulation","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"After discretization, we have a finite-dimensional problem:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"beginalign*\ntextminimize quad  J(z) \ntextsubject to quad  h(z) = 0 \n g(z) geq 0\nendalign*","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"where z = [x₁, u₁, x₂, u₂, ..., xₙ, uₙ, Δt₁, ..., Δtₙ] is the decision vector.","category":"page"},{"location":"generated/concepts/problem_formulation/#When-to-Use-DirectTrajOpt","page":"Problem Formulation","title":"When to Use DirectTrajOpt","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"DirectTrajOpt.jl is ideal when:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"✓ You have smooth dynamics\n✓ You need to handle constraints\n✓ You want flexibility in cost functions\n✓ You can provide reasonable initial guesses","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"It may not be ideal when:","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"✗ Dynamics are highly discontinuous\n✗ You need guaranteed global optimality\n✗ Real-time performance is critical (use MPC frameworks)","category":"page"},{"location":"generated/concepts/problem_formulation/#Summary","page":"Problem Formulation","title":"Summary","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Component Mathematical Form Implementation\nDecision Variables x, u, Δt NamedTrajectory\nObjective J(x, u) Objective (sum of terms)\nDynamics f(xₖ₊₁, xₖ, uₖ) = 0 AbstractIntegrator\nPath Constraints c(x, u) ≥ 0 AbstractConstraint\nBoundary Conditions x₁ = x_init, xₖ = x_goal initial, final in trajectory","category":"page"},{"location":"generated/concepts/problem_formulation/#Next-Steps","page":"Problem Formulation","title":"Next Steps","text":"","category":"section"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"Trajectories: Learn how to construct NamedTrajectory objects\nIntegrators: Understand how dynamics are discretized\nObjectives: Explore different cost functions\nConstraints: Add complex constraints to your problems","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"","category":"page"},{"location":"generated/concepts/problem_formulation/","page":"Problem Formulation","title":"Problem Formulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/#Constraints","page":"Library","title":"Constraints","text":"","category":"section"},{"location":"lib/#DirectTrajOpt.Constraints.EqualityConstraint","page":"Library","title":"DirectTrajOpt.Constraints.EqualityConstraint","text":"struct EqualityConstraint\n\nRepresents a linear equality constraint.\n\nFields\n\nts::AbstractArray{Int}: the time steps at which the constraint is applied\njs::AbstractArray{Int}: the components of the trajectory at which the constraint is applied\nvals::Vector{R}: the values of the constraint\nvardim::Int: the dimension of a single time step of the trajectory\nlabel::String: a label for the constraint\n\n\n\n\n\n","category":"type"},{"location":"lib/#DirectTrajOpt.Constraints.EqualityConstraint-Tuple{Symbol, AbstractVector{Int64}, Vector{Float64}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"DirectTrajOpt.Constraints.EqualityConstraint","text":"EqualityConstraint(\n    name::Symbol,\n    ts::Vector{Int},\n    val::Vector{Float64},\n    traj::NamedTrajectory;\n    label=\"equality constraint on trajectory variable [name]\"\n)\n\nConstructs equality constraint for trajectory variable in NamedTrajectory\n\n\n\n\n\n","category":"method"},{"location":"lib/#DirectTrajOpt.Constraints.GlobalEqualityConstraint-Tuple{Symbol, Vector{Float64}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"DirectTrajOpt.Constraints.GlobalEqualityConstraint","text":"GlobalEqualityConstraint(\n    name::Symbol,\n    val::Vector{Float64},\n    traj::NamedTrajectory;\n    label=\"equality constraint on global variable [name]\"\n)::EqualityConstraint\n\nConstructs equality constraint for global variable in NamedTrajectory\n\n\n\n\n\n","category":"method"},{"location":"lib/#Integrators","page":"Library","title":"Integrators","text":"","category":"section"},{"location":"lib/#DirectTrajOpt.Integrators.BilinearIntegrator","page":"Library","title":"DirectTrajOpt.Integrators.BilinearIntegrator","text":"BilinearIntegrator <: AbstractBilinearIntegrator\n\nIntegrator for control-linear dynamics of the form ẋ = G(u)x.\n\nThis integrator uses matrix exponential methods to compute accurate state transitions for bilinear systems where the system matrix depends linearly on the control input.\n\nFields\n\nG::Function: Function mapping control u to system matrix G(u)\nx_comps::Vector{Int}: Component indices for state variables\nu_comps::Vector{Int}: Component indices for control variables  \nΔt_comp::Int: Component index for time step\nz_dim::Int: Total dimension of knot point\nx_dim::Int: State dimension\nu_dim::Int: Control dimension\n\nConstructors\n\nBilinearIntegrator(G::Function, traj::NamedTrajectory, x::Symbol, u::Symbol)\nBilinearIntegrator(G::Function, traj::NamedTrajectory, xs::Vector{Symbol}, u::Symbol)\n\nArguments\n\nG: Function taking control u and returning state matrix (xdim × xdim)\ntraj: NamedTrajectory containing the optimization variables\nx or xs: State variable name(s)\nu: Control variable name\n\nDynamics\n\nComputes the constraint: x{k+1} - exp(Δt * G(uk)) * x_k = 0\n\nExample\n\n# Linear dynamics: ẋ = (A + Σᵢ uᵢ Bᵢ) x\nA = [-0.1 1.0; -1.0 -0.1]\nB = [0.0 0.0; 0.0 1.0]\nG = u -> A + u[1] * B\n\nintegrator = BilinearIntegrator(G, traj, :x, :u)\n\n\n\n\n\n","category":"type"},{"location":"lib/#DirectTrajOpt.Integrators.dense-Tuple{Any, Any, Any}","page":"Library","title":"DirectTrajOpt.Integrators.dense","text":"dense(vals, structure, shape)\n\nConvert sparse data to dense matrix.\n\nArguments\n\nvals: vector of values\nstructure: vector of tuples of indices\nshape: tuple of matrix dimensions\n\n\n\n\n\n","category":"method"},{"location":"lib/#DirectTrajOpt.Integrators.show_diffs-Tuple{AbstractMatrix, AbstractMatrix}","page":"Library","title":"DirectTrajOpt.Integrators.show_diffs","text":"show_diffs(A::Matrix, B::Matrix)\n\nShow differences between matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Objectives","page":"Library","title":"Objectives","text":"","category":"section"},{"location":"lib/#DirectTrajOpt.Objectives.Objective","page":"Library","title":"DirectTrajOpt.Objectives.Objective","text":"Objective\n\nA structure representing an objective function for trajectory optimization.\n\nAn objective function consists of the cost function itself along with its first and second derivatives for gradient-based optimization. The structure supports automatic differentiation and sparse Hessian representations.\n\nFields\n\nL::Function: Objective function that takes trajectory vector Z⃗ and returns a scalar cost\n∇L::Function: Gradient function returning ∂L/∂Z⃗\n∂²L::Union{Function, Nothing}: Hessian function returning non-zero Hessian entries\n∂²L_structure::Union{Function, Nothing}: Function returning sparsity structure of Hessian\n\nOperators\n\nObjectives support addition and scalar multiplication:\n\nobj1 + obj2: Combine objectives by summing costs and derivatives\nα * obj: Scale objective by constant α\n\nExample\n\n# Create a regularization objective\nobj = QuadraticRegularizer(:u, traj, 1e-2)\n\n# Combine multiple objectives  \ntotal_obj = obj1 + obj2 + 0.1 * obj3\n\n\n\n\n\n","category":"type"},{"location":"lib/#DirectTrajOpt.Objectives.GlobalObjective-Tuple{Function, AbstractVector{Symbol}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"DirectTrajOpt.Objectives.GlobalObjective","text":"GlobalObjective(\n    ℓ::Function,\n    global_names::AbstractVector{Symbol},\n    traj::NamedTrajectory;\n    kwargs...\n)\nGlobalObjective(\n    ℓ::Function,\n    global_name::Symbol,\n    traj::NamedTrajectory;\n    kwargs...\n)\n\nCreate an objective that only involves the global components.\n\n\n\n\n\n","category":"method"},{"location":"lib/#DirectTrajOpt.Objectives.KnotPointObjective-Tuple{Function, AbstractVector{Symbol}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, AbstractVector}","page":"Library","title":"DirectTrajOpt.Objectives.KnotPointObjective","text":"KnotPointObjective(\n    ℓ::Function,\n    names::AbstractVector{Symbol},\n    traj::NamedTrajectory,\n    params::AbstractVector;\n    kwargs...\n)\nKnotPointObjective(\n    ℓ::Function,\n    names::AbstractVector{Symbol},\n    traj::NamedTrajectory;\n    kwargs...\n)\nKnotPointObjective(\n    ℓ::Function,\n    name::Symbol,\n    args...;\n    kwargs...\n)\n\nCreate a knot point summed objective function for trajectory optimization, where ℓ(x, p)  on trajectory knot point variables x with parameters p. If the parameters argument is  omitted, ℓ(x) is assumed to be a function of x only.\n\nFor multiple variables, the function ℓ can accept either:\n\nSeparate arguments: ℓ(x, u) for variables [:x, :u]\nConcatenated vector: ℓ(xu) where xu = [x; u]\n\nThe constructor automatically detects which form ℓ expects.\n\nArguments\n\nℓ::Function: Function that defines the objective, ℓ(x, p) or ℓ(x).\nFor single variable: ℓ(x) where x is the variable values at a knot point\nFor multiple variables: ℓ(x, u) or ℓ(xu) depending on preference\nnames::AbstractVector{Symbol}: Names of the trajectory variables to be optimized.\ntraj::NamedTrajectory: The trajectory on which the objective is defined.\nparams::AbstractVector: Parameters p for the objective function ℓ, for each time.\n\nKeyword Arguments\n\ntimes::AbstractVector{Int}=1:traj.N: Time indices at which the objective is evaluated.\nQs::AbstractVector{Float64}=ones(traj.N): Weights for the objective function at each time.\n\nExamples\n\n# Single variable objective\nobj = KnotPointObjective(\n    x -> norm(x)^2,\n    [:x], traj\n)\n\n# Multiple variables with separate arguments (recommended)\nobj = KnotPointObjective(\n    (x, u) -> x[1]^2 + u[1]^2,\n    [:x, :u], traj\n)\n\n# Multiple variables with concatenated vector\nobj = KnotPointObjective(\n    xu -> xu[1]^2 + xu[3]^2,  # xu = [x[1], x[2], u[1]]\n    [:x, :u], traj\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/#DirectTrajOpt.Objectives.MinimumTimeObjective-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"DirectTrajOpt.Objectives.MinimumTimeObjective","text":"MinimumTimeObjective\n\nA type of objective that counts the time taken to complete a task.  D is a scaling factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/#DirectTrajOpt.Objectives.QuadraticRegularizer-Tuple{Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, AbstractVector{<:Real}}","page":"Library","title":"DirectTrajOpt.Objectives.QuadraticRegularizer","text":"QuadraticRegularizer(\n    name::Symbol,\n    traj::NamedTrajectory,\n    R::Union{Real, AbstractVector{<:Real}};\n    baseline::AbstractMatrix{<:Real}=zeros(traj.dims[name], traj.N),\n    times::AbstractVector{Int}=1:traj.N\n)\n\nCreate a quadratic regularization objective for a trajectory component.\n\nMinimizes the weighted squared deviation from a baseline trajectory, integrated over time:\n\nJ = sum_k in texttimes frac12 (v_k - v_textbaseline)^T R (v_k - v_textbaseline) Delta t\n\nwhere v_k is the trajectory component at knot point k.\n\nArguments\n\nname::Symbol: Name of the trajectory component to regularize\ntraj::NamedTrajectory: The trajectory containing the component\nR: Regularization weight(s). Can be:\nScalar: same weight for all components\nVector: individual weights for each component dimension\nbaseline::AbstractMatrix: Target values (default: zeros). Size: (component_dim × N)\ntimes::AbstractVector{Int}: Time indices to include in regularization (default: all)\n\nReturns\n\nObjective: Regularization objective with gradient and Hessian\n\nExamples\n\n# Regularize control with uniform weight\nobj = QuadraticRegularizer(:u, traj, 1e-2)\n\n# Regularize with different weights per component\nobj = QuadraticRegularizer(:u, traj, [1e-2, 1e-3])\n\n# Regularize around a reference trajectory\nobj = QuadraticRegularizer(:x, traj, 1.0, baseline=x_ref)\n\n# Only regularize middle time steps\nobj = QuadraticRegularizer(:u, traj, 1e-2, times=2:traj.N-1)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Dynamics","page":"Library","title":"Dynamics","text":"","category":"section"},{"location":"lib/#DirectTrajOpt.Dynamics.TrajectoryDynamics","page":"Library","title":"DirectTrajOpt.Dynamics.TrajectoryDynamics","text":"TrajectoryDynamics\n\nRepresents the dynamics of a trajectory optimization problem through integrators.\n\nThis structure encapsulates the dynamics constraints that enforce consistency between consecutive time steps in the trajectory. It uses integrators to define how the state evolves from one time step to the next and provides automatic differentiation support through Jacobian and Hessian computations.\n\nFields\n\nF!::Function: In-place function computing dynamics violations δ = f(zₖ, zₖ₊₁)\n∂F!::Function: In-place function computing Jacobian of dynamics\n∂fs::Vector{SparseMatrixCSC}: Cached Jacobian matrices for each time step\nμ∂²F!::Function: In-place function computing Hessian of Lagrangian\nμ∂²fs::Vector{SparseMatrixCSC}: Cached Hessian matrices for each time step\nμ∂²F_structure::SparseMatrixCSC: Sparsity structure of full trajectory Hessian\ndim::Int: Total dimension of dynamics (sum of all integrator state dimensions)\n\nConstructor\n\nTrajectoryDynamics(\n    integrators::Vector{<:AbstractIntegrator},\n    traj::NamedTrajectory;\n    verbose=false\n)\n\nCreate trajectory dynamics from integrators and a trajectory structure.\n\nExample\n\nG = rand(2, 2)\nintegrator = BilinearIntegrator(G, traj, :x, :u)\ndynamics = TrajectoryDynamics(integrator, traj)\n\n\n\n\n\n","category":"type"},{"location":"lib/#Problems","page":"Library","title":"Problems","text":"","category":"section"},{"location":"lib/#DirectTrajOpt.Problems.DirectTrajOptProblem","page":"Library","title":"DirectTrajOpt.Problems.DirectTrajOptProblem","text":"mutable struct DirectTrajOptProblem\n\nA direct trajectory optimization problem containing all information needed for setup and solution.\n\nFields\n\ntrajectory::NamedTrajectory: The trajectory containing optimization variables and data\nobjective::Objective: The objective function to minimize\ndynamics::TrajectoryDynamics: The system dynamics (integrators)\nconstraints::Vector{<:AbstractConstraint}: Constraints on the trajectory\n\nConstructors\n\nDirectTrajOptProblem(\n    traj::NamedTrajectory,\n    obj::Objective,\n    integrators::Vector{<:AbstractIntegrator};\n    constraints::Vector{<:AbstractConstraint}=AbstractConstraint[]\n)\n\nCreate a problem from a trajectory, objective, and integrators. Trajectory constraints (initial, final, bounds) are automatically extracted and added to the constraint list.\n\nExample\n\ntraj = NamedTrajectory((x = rand(2, 10), u = rand(1, 10)), timestep=:Δt)\nobj = QuadraticRegularizer(:u, traj, 1.0)\nintegrator = BilinearIntegrator(G, traj, :x, :u)\nprob = DirectTrajOptProblem(traj, obj, integrator)\n\n\n\n\n\n","category":"type"},{"location":"lib/#DirectTrajOpt.Problems.get_trajectory_constraints-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Library","title":"DirectTrajOpt.Problems.get_trajectory_constraints","text":"get_trajectory_constraints(traj::NamedTrajectory)\n\nExtract and create constraints from a NamedTrajectory's initial, final, and bounds specifications.\n\nArguments\n\ntraj::NamedTrajectory: Trajectory with specified initial conditions, final conditions, and/or bounds\n\nReturns\n\nVector{AbstractConstraint}: Vector of constraints including:\nInitial value equality constraints (from traj.initial)\nFinal value equality constraints (from traj.final)\nBounds constraints (from traj.bounds)\n\nDetails\n\nThe function automatically handles time indices based on which constraints are specified:\n\nIf both initial and final constraints exist for a component, bounds apply to interior points (2:N-1)\nIf only initial exists, bounds apply from second point onward (2:N)\nIf only final exists, bounds apply up to second-to-last point (1:N-1)\nIf neither exist, bounds apply to all time points (1:N)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Problem-Solvers","page":"Library","title":"Problem Solvers","text":"","category":"section"},{"location":"lib/#Problem-Solvers-2","page":"Library","title":"Problem Solvers","text":"","category":"section"},{"location":"lib/#DirectTrajOpt.IpoptSolverExt.IpoptOptions","page":"Library","title":"DirectTrajOpt.IpoptSolverExt.IpoptOptions","text":"Solver options for Ipopt\n\nhttps://coin-or.github.io/Ipopt/OPTIONS.html#OPT_print_options_documentation\n\n\n\n\n\n","category":"type"},{"location":"lib/#DirectTrajOpt.Solvers.solve!-Tuple{DirectTrajOptProblem}","page":"Library","title":"DirectTrajOpt.Solvers.solve!","text":"solve!(\n    prob::DirectTrajOptProblem;\n    options::IpoptOptions=IpoptOptions(),\n    max_iter::Int=options.max_iter,\n    verbose::Bool=true,\n    linear_solver::String=options.linear_solver,\n    print_level::Int=options.print_level,\n    callback=nothing\n)\n\nSolve a direct trajectory optimization problem using Ipopt.\n\nArguments\n\nprob::DirectTrajOptProblem: The trajectory optimization problem to solve.\noptions::IpoptOptions: Ipopt solver options. Default is IpoptOptions().\nmax_iter::Int: Maximum number of iterations for the optimization solver.\nverbose::Bool: If true, print solver progress information.\nlinear_solver::String: Linear solver to use (e.g., \"mumps\", \"pardiso\", \"ma27\", \"ma57\", \"ma77\", \"ma86\", \"ma97\").\nprint_level::Int: Ipopt print level (0-12). Higher values provide more detailed output.\ncallback::Function: Optional callback function to execute during optimization.\n\nReturns\n\nnothing: The problem's trajectory is updated in place with the optimized solution.\n\nExample\n\nprob = DirectTrajOptProblem(trajectory, objective, dynamics)\nsolve!(prob; max_iter=100, verbose=true)\n\n\n\n\n\n","category":"method"},{"location":"generated/concepts/trajectories/#Trajectories","page":"Trajectories","title":"Trajectories","text":"","category":"section"},{"location":"generated/concepts/trajectories/#What-is-a-NamedTrajectory?","page":"Trajectories","title":"What is a NamedTrajectory?","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"A NamedTrajectory is the central data structure in DirectTrajOpt.jl. It stores:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"States and controls over time\nTime step information (fixed or variable)\nBoundary conditions (initial, final, goal)\nBounds on variables\nMetadata about which variables are controls, timesteps, etc.","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"using DirectTrajOpt\nusing NamedTrajectories","category":"page"},{"location":"generated/concepts/trajectories/#Basic-Construction","page":"Trajectories","title":"Basic Construction","text":"","category":"section"},{"location":"generated/concepts/trajectories/#Minimal-Example","page":"Trajectories","title":"Minimal Example","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"N = 10  # number of time steps","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Specify component data as a NamedTuple:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"data = (\n    x = randn(2, N),    # 2D state\n    u = randn(1, N),    # 1D control\n    Δt = fill(0.1, N)   # time step\n)\n\ntraj = NamedTrajectory(\n    data;\n    timestep=:Δt,   # which variable represents time\n    controls=:u     # which variable(s) are controls\n)","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Access components:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"println(\"State at time 1: \", traj.x[:, 1])\nprintln(\"Control at time 5: \", traj.u[:, 5])\nprintln(\"Total time: \", sum(traj.Δt))","category":"page"},{"location":"generated/concepts/trajectories/#Trajectory-Components","page":"Trajectories","title":"Trajectory Components","text":"","category":"section"},{"location":"generated/concepts/trajectories/#States","page":"Trajectories","title":"States","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Variables that represent the system configuration. Can be multiple state vectors:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_multi = NamedTrajectory(\n    (\n        position = randn(3, N),  # 3D position\n        velocity = randn(3, N),  # 3D velocity\n        u = randn(2, N),\n        Δt = fill(0.1, N)\n    );\n    timestep=:Δt,\n    controls=:u\n)","category":"page"},{"location":"generated/concepts/trajectories/#Controls","page":"Trajectories","title":"Controls","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Variables that you can actuate. Can specify multiple control variables:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_multi_control = NamedTrajectory(\n    (\n        x = randn(2, N),\n        u1 = randn(1, N),\n        u2 = randn(1, N),\n        Δt = fill(0.1, N)\n    );\n    timestep=:Δt,\n    controls=(:u1, :u2)\n)","category":"page"},{"location":"generated/concepts/trajectories/#Time-Steps","page":"Trajectories","title":"Time Steps","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Fixed time: All time steps equal (constant Δt)","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_fixed_time = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,  # symbol pointing to timestep component\n    controls=:u\n)","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Free time: Each time step is a decision variable (with bounds)","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_free_time = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=(:u, :Δt),  # Include Δt in controls for optimization\n    bounds=(Δt = (0.01, 0.5),)  # Set bounds on time steps\n)","category":"page"},{"location":"generated/concepts/trajectories/#Boundary-Conditions","page":"Trajectories","title":"Boundary Conditions","text":"","category":"section"},{"location":"generated/concepts/trajectories/#Initial-Conditions","page":"Trajectories","title":"Initial Conditions","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Fix the starting state:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_initial = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = [0.0, 0.0],)  # x₁ = [0, 0]\n)","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Can also fix initial controls:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_initial_u = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = [0.0, 0.0], u = [0.0])  # x₁ = [0, 0], u₁ = 0\n)","category":"page"},{"location":"generated/concepts/trajectories/#Final-Conditions","page":"Trajectories","title":"Final Conditions","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Fix the ending state:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_final = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    final=(x = [1.0, 0.0],)  # xₖ = [1, 0]\n)","category":"page"},{"location":"generated/concepts/trajectories/#Goal-Conditions","page":"Trajectories","title":"Goal Conditions","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Similar to final, but typically used with terminal cost instead of hard constraint:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_goal = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    goal=(x = [1.0, 0.0],)  # target: xₖ → [1, 0]\n)","category":"page"},{"location":"generated/concepts/trajectories/#Complete-Example","page":"Trajectories","title":"Complete Example","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_complete = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = [0.0, 0.0], u = [0.0]),\n    final=(u = [0.0],),\n    goal=(x = [1.0, 0.0],)\n)","category":"page"},{"location":"generated/concepts/trajectories/#Bounds-on-Variables","page":"Trajectories","title":"Bounds on Variables","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Bounds constrain variables to lie within specified ranges.","category":"page"},{"location":"generated/concepts/trajectories/#Scalar-Bounds-(Symmetric)","page":"Trajectories","title":"Scalar Bounds (Symmetric)","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"A single number creates symmetric bounds: -bound ≤ var ≤ bound","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_scalar_bound = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    bounds=(u = 1.0,)  # -1 ≤ u ≤ 1 for all components\n)","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Applies to all components of the variable:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"println(\"u bounds: \", traj_scalar_bound.bounds.u)","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Output: ([-1.0], [1.0])","category":"page"},{"location":"generated/concepts/trajectories/#Tuple-Bounds-(Asymmetric)","page":"Trajectories","title":"Tuple Bounds (Asymmetric)","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"A tuple (lower, upper) creates asymmetric bounds:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_tuple_bound = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    bounds=(u = (-2.0, 1.0),)  # -2 ≤ u ≤ 1\n)\n\nprintln(\"u bounds: \", traj_tuple_bound.bounds.u)","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Output: ([-2.0], [1.0])","category":"page"},{"location":"generated/concepts/trajectories/#Vector-Bounds-(Component-wise-Symmetric)","page":"Trajectories","title":"Vector Bounds (Component-wise Symmetric)","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"A vector creates component-specific symmetric bounds:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_vector_bound = NamedTrajectory(\n    (x = randn(2, N), u = randn(2, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    bounds=(u = [1.0, 2.0],)  # -1 ≤ u₁ ≤ 1, -2 ≤ u₂ ≤ 2\n)\n\nprintln(\"u bounds: \", traj_vector_bound.bounds.u)","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Output: ([-1.0, -2.0], [1.0, 2.0])","category":"page"},{"location":"generated/concepts/trajectories/#Tuple-of-Vectors-(Component-wise-Asymmetric)","page":"Trajectories","title":"Tuple of Vectors (Component-wise Asymmetric)","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"The most general form - specify lower and upper for each component:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_full_bound = NamedTrajectory(\n    (x = randn(2, N), u = randn(2, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    bounds=(u = ([-2.0, -1.0], [1.0, 3.0]),)  # -2 ≤ u₁ ≤ 1, -1 ≤ u₂ ≤ 3\n)\n\nprintln(\"u bounds: \", traj_full_bound.bounds.u)","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Output: ([-2.0, -1.0], [1.0, 3.0])","category":"page"},{"location":"generated/concepts/trajectories/#Multiple-Variable-Bounds","page":"Trajectories","title":"Multiple Variable Bounds","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_multi_bounds = NamedTrajectory(\n    (x = randn(2, N), u = randn(2, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    bounds=(\n        x = 5.0,           # -5 ≤ x ≤ 5 (both components)\n        u = [1.0, 2.0],    # component-specific\n        Δt = (0.05, 0.15)  # 0.05 ≤ Δt ≤ 0.15\n    )\n)","category":"page"},{"location":"generated/concepts/trajectories/#Time-Step-Bounds","page":"Trajectories","title":"Time Step Bounds","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"For free-time problems, bound the time steps:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_time_bounds = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    bounds=(\n        u = 1.0,\n        Δt = (0.01, 0.2)  # 0.01 ≤ Δt ≤ 0.2\n    )\n)","category":"page"},{"location":"generated/concepts/trajectories/#Accessing-Trajectory-Data","page":"Trajectories","title":"Accessing Trajectory Data","text":"","category":"section"},{"location":"generated/concepts/trajectories/#Direct-Access","page":"Trajectories","title":"Direct Access","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"x_data = traj.x           # Get all states (2 × N matrix)\nu_data = traj.u           # Get all controls (1 × N matrix)\nx_final = traj.x[:, end]  # Get final state","category":"page"},{"location":"generated/concepts/trajectories/#Metadata","page":"Trajectories","title":"Metadata","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"println(\"Number of time steps: \", traj.N)\nprintln(\"State dimension: \", traj.dims.x)\nprintln(\"Control dimension: \", traj.dims.u)\nprintln(\"Total dimension: \", traj.dim)","category":"page"},{"location":"generated/concepts/trajectories/#Time-Information","page":"Trajectories","title":"Time Information","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"times = get_times(traj)  # Cumulative time at each knot point\ntotal_time = sum(traj.Δt)","category":"page"},{"location":"generated/concepts/trajectories/#Building-Trajectories-for-Optimization","page":"Trajectories","title":"Building Trajectories for Optimization","text":"","category":"section"},{"location":"generated/concepts/trajectories/#Good-Initialization-Matters","page":"Trajectories","title":"Good Initialization Matters","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Start with a reasonable guess:","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Linear interpolation between initial and final states\nZero or small random controls\nUniform time steps","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"x_init = [0.0, 0.0]\nx_goal = [1.0, 1.0]","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Linear interpolation","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"x_guess = hcat([x_init + (x_goal - x_init) * (t / (N-1)) for t in 0:N-1]...)\n\ntraj_good_init = NamedTrajectory(\n    (\n        x = x_guess,\n        u = zeros(1, N),\n        Δt = fill(0.1, N)\n    );\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = x_init,),\n    final=(x = x_goal,)\n)","category":"page"},{"location":"generated/concepts/trajectories/#Common-Patterns","page":"Trajectories","title":"Common Patterns","text":"","category":"section"},{"location":"generated/concepts/trajectories/#State-Transfer-Problem","page":"Trajectories","title":"State Transfer Problem","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Drive from initial to final state with bounded controls","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_transfer = NamedTrajectory(\n    (x = randn(3, 50), u = randn(2, 50), Δt = fill(0.1, 50));\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = zeros(3),),\n    final=(x = ones(3),),\n    bounds=(u = 1.0,)\n)","category":"page"},{"location":"generated/concepts/trajectories/#Minimum-Time-Problem","page":"Trajectories","title":"Minimum Time Problem","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Free time steps, bounded, with time regularization","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_mintime = NamedTrajectory(\n    (x = randn(2, 30), u = randn(1, 30), Δt = fill(0.1, 30));\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = [0.0, 0.0],),\n    final=(x = [1.0, 0.0],),\n    bounds=(\n        u = 1.0,\n        Δt = (0.01, 0.5)\n    )\n)","category":"page"},{"location":"generated/concepts/trajectories/#Smooth-Control-Problem","page":"Trajectories","title":"Smooth Control Problem","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Include control derivatives for smoothness","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"traj_smooth = NamedTrajectory(\n    (\n        x = randn(2, 40),\n        u = randn(2, 40),\n        du = zeros(2, 40),   # control derivative\n        Δt = fill(0.1, 40)\n    );\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = [0.0, 0.0], u = [0.0, 0.0]),\n    final=(x = [1.0, 0.0], u = [0.0, 0.0]),\n    bounds=(u = 1.0,)\n)","category":"page"},{"location":"generated/concepts/trajectories/#Summary","page":"Trajectories","title":"Summary","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Concept Syntax Example\nFixed time timestep=0.1 timestep=0.1\nFree time timestep=:Δt timestep=:Δt\nInitial condition initial=(x = [...],) initial=(x = [0, 0],)\nFinal condition final=(x = [...],) final=(x = [1, 0],)\nScalar bound bounds=(u = 1.0,) -1 ≤ u ≤ 1\nTuple bound bounds=(u = (-2, 1),) -2 ≤ u ≤ 1\nVector bound bounds=(u = [1, 2],) -1 ≤ u₁ ≤ 1, -2 ≤ u₂ ≤ 2\nFull bound bounds=(u = ([-2,-1], [1,3]),) -2 ≤ u₁ ≤ 1, -1 ≤ u₂ ≤ 3","category":"page"},{"location":"generated/concepts/trajectories/#Next-Steps","page":"Trajectories","title":"Next Steps","text":"","category":"section"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"Integrators: Learn how dynamics are encoded\nObjectives: Define cost functions on trajectories\nTutorials: See complete examples using trajectories","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"","category":"page"},{"location":"generated/concepts/trajectories/","page":"Trajectories","title":"Trajectories","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/concepts/integrators/#Integrators","page":"Integrators","title":"Integrators","text":"","category":"section"},{"location":"generated/concepts/integrators/#What-are-Integrators?","page":"Integrators","title":"What are Integrators?","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Integrators discretize continuous-time dynamics into constraints for the NLP solver. They implement the relationship:","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"x_k+1 = Phi(x_k u_k Delta t_k)","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"where Φ approximates the continuous evolution ẋ = f(x, u, t).","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"using DirectTrajOpt\nusing NamedTrajectories\nusing LinearAlgebra","category":"page"},{"location":"generated/concepts/integrators/#BilinearIntegrator","page":"Integrators","title":"BilinearIntegrator","text":"","category":"section"},{"location":"generated/concepts/integrators/#Overview","page":"Integrators","title":"Overview","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Used for control-linear (bilinear) dynamics:","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"dotx = (G_0 + sum_i u_i G_i) x","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"where:","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"G₀ is the drift term (dynamics with no control)\nGᵢ are the drive terms (how controls affect the system)\nuᵢ are the control inputs","category":"page"},{"location":"generated/concepts/integrators/#How-it-Works","page":"Integrators","title":"How it Works","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Uses the matrix exponential for exact integration:","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"x_k+1 = exp(Delta t cdot G(u_k)) x_k","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"where G(u) = G₀ + Σᵢ uᵢ Gᵢ.","category":"page"},{"location":"generated/concepts/integrators/#Example:-Simple-2D-System","page":"Integrators","title":"Example: Simple 2D System","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"N = 50\ntraj = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = [1.0, 0.0],),\n    final=(x = [0.0, 1.0],)\n)","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Define drift (natural dynamics) and drives (control terms)","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"G_drift = [-0.1 1.0; -1.0 -0.1]     # Damped oscillator\nG_drives = [[0.0 1.0; 1.0 0.0]]     # Symmetric control coupling","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Create generator function","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"G = u -> G_drift + sum(u .* G_drives)","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Create integrator","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"integrator = BilinearIntegrator(G, traj, :x, :u)","category":"page"},{"location":"generated/concepts/integrators/#Multiple-Drives-Example","page":"Integrators","title":"Multiple Drives Example","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"traj_multi = NamedTrajectory(\n    (x = randn(3, N), u = randn(2, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u\n)\n\nG_drift_3d = [\n    0.0  1.0  0.0;\n   -1.0  0.0  0.0;\n    0.0  0.0 -0.1\n]\n\nG_drives_3d = [\n    [1.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0],  # Drive 1\n    [0.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 0.0]   # Drive 2\n]\n\nG_multi = u -> G_drift_3d + sum(u .* G_drives_3d)\n\nintegrator_multi = BilinearIntegrator(G_multi, traj_multi, :x, :u)","category":"page"},{"location":"generated/concepts/integrators/#When-to-Use-BilinearIntegrator","page":"Integrators","title":"When to Use BilinearIntegrator","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"✓ Quantum systems (Hamiltonian evolution) ✓ Rotating systems (attitude dynamics) ✓ Systems linear in controls ✓ When you want exact integration (no discretization error)","category":"page"},{"location":"generated/concepts/integrators/#TimeDependentBilinearIntegrator","page":"Integrators","title":"TimeDependentBilinearIntegrator","text":"","category":"section"},{"location":"generated/concepts/integrators/#Overview-2","page":"Integrators","title":"Overview","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"For time-varying bilinear dynamics:","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"dotx = (G_0(t) + sum_i u_i(t) G_i(t)) x","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"The generator function now depends on both control and time.","category":"page"},{"location":"generated/concepts/integrators/#Example:-Periodic-Disturbance","page":"Integrators","title":"Example: Periodic Disturbance","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"traj_td = NamedTrajectory(\n    (\n        x = randn(2, N),\n        u = randn(1, N),\n        t = collect(range(0, 5, N)),  # time variable\n        Δt = fill(0.1, N)\n    );\n    timestep=:Δt,\n    controls=:u\n)","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Time-dependent generator","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"G_td = (u, t) -> [-0.1 + 0.5*sin(t)  1.0; -1.0  -0.1] + u[1] * [0.0 1.0; 1.0 0.0]\n\nintegrator_td = TimeDependentBilinearIntegrator(G_td, traj_td, :x, :u, :t)","category":"page"},{"location":"generated/concepts/integrators/#When-to-Use-TimeDependentBilinearIntegrator","page":"Integrators","title":"When to Use TimeDependentBilinearIntegrator","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"✓ Time-varying Hamiltonians ✓ Systems with periodic forcing ✓ Carrier wave modulation (e.g., rotating frame transformations)","category":"page"},{"location":"generated/concepts/integrators/#DerivativeIntegrator","page":"Integrators","title":"DerivativeIntegrator","text":"","category":"section"},{"location":"generated/concepts/integrators/#Overview-3","page":"Integrators","title":"Overview","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Enforces derivative relationships between trajectory components:","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"fracd(textvar)dt = textderiv","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"This is used for smoothness or when controls are derivatives of other variables.","category":"page"},{"location":"generated/concepts/integrators/#Example:-Smooth-Controls","page":"Integrators","title":"Example: Smooth Controls","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"traj_smooth = NamedTrajectory(\n    (\n        x = randn(2, N),\n        u = randn(2, N),\n        du = zeros(2, N),   # control derivative\n        Δt = fill(0.1, N)\n    );\n    timestep=:Δt,\n    controls=:u,\n    initial=(u = [0.0, 0.0],),\n    final=(u = [0.0, 0.0],)\n)","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Enforce du/dt = du","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"deriv_integrator = DerivativeIntegrator(traj_smooth, :u, :du)","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Now you can penalize du to get smooth controls: obj = QuadraticRegularizer(:u, trajsmooth, 1e-2) obj += QuadraticRegularizer(:du, trajsmooth, 1e-1)  # Smoothness penalty","category":"page"},{"location":"generated/concepts/integrators/#Multiple-Derivative-Orders","page":"Integrators","title":"Multiple Derivative Orders","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"traj_smooth2 = NamedTrajectory(\n    (\n        x = randn(2, N),\n        u = randn(1, N),\n        du = zeros(1, N),\n        ddu = zeros(1, N),\n        Δt = fill(0.1, N)\n    );\n    timestep=:Δt,\n    controls=:u\n)","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Chain derivatives: d(u)/dt = du, d(du)/dt = ddu","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"deriv_u = DerivativeIntegrator(traj_smooth2, :u, :du)\nderiv_du = DerivativeIntegrator(traj_smooth2, :du, :ddu)","category":"page"},{"location":"generated/concepts/integrators/#When-to-Use-DerivativeIntegrator","page":"Integrators","title":"When to Use DerivativeIntegrator","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"✓ Enforce smooth, implementable controls ✓ Acceleration limits (when control is jerk) ✓ Tracking derivative information","category":"page"},{"location":"generated/concepts/integrators/#TimeIntegrator","page":"Integrators","title":"TimeIntegrator","text":"","category":"section"},{"location":"generated/concepts/integrators/#Overview-4","page":"Integrators","title":"Overview","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Manages time evolution for the time variable itself:","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"t_k+1 = t_k + Delta t_k","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Usually only needed when you explicitly track time as a state.","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"traj_time = NamedTrajectory(\n    (\n        x = randn(2, N),\n        u = randn(1, N),\n        t = zeros(1, N),\n        Δt = fill(0.1, N)\n    );\n    timestep=:Δt,\n    controls=:u\n)\n\ntime_integrator = TimeIntegrator(traj_time, :t)","category":"page"},{"location":"generated/concepts/integrators/#When-to-Use-TimeIntegrator","page":"Integrators","title":"When to Use TimeIntegrator","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"✓ Time-dependent dynamics need explicit time ✓ Time-dependent cost functions ✓ Tracking total elapsed time","category":"page"},{"location":"generated/concepts/integrators/#Combining-Multiple-Integrators","page":"Integrators","title":"Combining Multiple Integrators","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"You can use multiple integrators simultaneously:","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"traj_combined = NamedTrajectory(\n    (\n        x = randn(2, N),\n        u = randn(2, N),\n        du = zeros(2, N),\n        t = collect(range(0, 5, N)),\n        Δt = fill(0.1, N)\n    );\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = [0.0, 0.0], u = [0.0, 0.0]),\n    final=(u = [0.0, 0.0],)\n)","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Time-varying dynamics","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"G_combined = (u, t) -> [-0.1 1.0; -1.0 -0.1] + sum(u .* [[0.0 1.0; 1.0 0.0], [1.0 0.0; 0.0 1.0]])\n\nintegrators = [\n    TimeDependentBilinearIntegrator(G_combined, traj_combined, :x, :u, :t),\n    DerivativeIntegrator(traj_combined, :u, :du),\n    TimeIntegrator(traj_combined, :t)\n]","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Create problem with multiple integrators","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"G_drift_simple = [-0.1 1.0; -1.0 -0.1]\nG_drives_simple = [[0.0 1.0; 1.0 0.0]]\nG_simple = u -> G_drift_simple + sum(u .* G_drives_simple)\n\nobj = QuadraticRegularizer(:u, traj_combined, 1e-2)\nobj += QuadraticRegularizer(:du, traj_combined, 1e-1)","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Note: Using simpler BilinearIntegrator for this example","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"integrators_simple = [\n    BilinearIntegrator(G_simple, traj_combined, :x, :u),\n    DerivativeIntegrator(traj_combined, :u, :du)\n]\n\nprob = DirectTrajOptProblem(traj_combined, obj, integrators_simple)","category":"page"},{"location":"generated/concepts/integrators/#Integration-Methods-Comparison","page":"Integrators","title":"Integration Methods Comparison","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Integrator Dynamics Type Accuracy Use Case\nBilinearIntegrator Control-linear Exact Quantum, rotation\nTimeDependentBilinearIntegrator Time-varying control-linear Exact Modulated systems\nDerivativeIntegrator Derivative relation Exact Smoothness\nTimeIntegrator Time evolution Exact Time tracking","category":"page"},{"location":"generated/concepts/integrators/#Custom-Integrators","page":"Integrators","title":"Custom Integrators","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"You can implement custom integrators by subtyping AbstractIntegrator and defining the constraint function. See the Advanced Topics section for details.","category":"page"},{"location":"generated/concepts/integrators/#Interface-Requirements","page":"Integrators","title":"Interface Requirements","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"struct MyIntegrator <: AbstractIntegrator\n    # ... fields ...\nend\n\n# Implement constraint evaluation\nfunction (int::MyIntegrator)(δ, zₖ, zₖ₊₁, k)\n    # Compute constraint: δ = xₖ₊₁ - Φ(xₖ, uₖ, Δtₖ)\n    # where Φ is your integration scheme\nend","category":"page"},{"location":"generated/concepts/integrators/#Best-Practices","page":"Integrators","title":"Best Practices","text":"","category":"section"},{"location":"generated/concepts/integrators/#Initialization","page":"Integrators","title":"Initialization","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Start with good initial guesses for states and controls\nFor smooth control problems, initialize derivatives to zero\nUse linear interpolation for states between boundary conditions","category":"page"},{"location":"generated/concepts/integrators/#Performance","page":"Integrators","title":"Performance","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Matrix exponential (BilinearIntegrator) is efficient for small systems (n < 20)\nFor large systems, consider sparse representations\nDerivativeIntegrator is cheap (just finite differences)","category":"page"},{"location":"generated/concepts/integrators/#Numerical-Stability","page":"Integrators","title":"Numerical Stability","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Keep time steps reasonable (not too large)\nFor stiff systems, smaller time steps help\nBilinearIntegrator handles stiff systems well","category":"page"},{"location":"generated/concepts/integrators/#Common-Patterns","page":"Integrators","title":"Common Patterns","text":"","category":"section"},{"location":"generated/concepts/integrators/#Pattern-1:-Basic-Bilinear-Problem","page":"Integrators","title":"Pattern 1: Basic Bilinear Problem","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"G_basic = u -> [-0.1 1.0; -1.0 -0.1] + u[1] * [0.0 1.0; 1.0 0.0]","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"integrator = BilinearIntegrator(G_basic, traj, :x, :u)","category":"page"},{"location":"generated/concepts/integrators/#Pattern-2:-Smooth-Control-Problem","page":"Integrators","title":"Pattern 2: Smooth Control Problem","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"integrators = [     BilinearIntegrator(G, traj, :x, :u),     DerivativeIntegrator(traj, :u, :du) ]","category":"page"},{"location":"generated/concepts/integrators/#Pattern-3:-Time-Dependent-with-Smoothness","page":"Integrators","title":"Pattern 3: Time-Dependent with Smoothness","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"integrators = [     TimeDependentBilinearIntegrator(G_td, traj, :x, :u, :t),     DerivativeIntegrator(traj, :u, :du),     TimeIntegrator(traj, :t) ]","category":"page"},{"location":"generated/concepts/integrators/#Summary","page":"Integrators","title":"Summary","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Key Takeaways:","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Integrators convert continuous dynamics to discrete constraints\nBilinearIntegrator is the workhorse for control-linear systems\nDerivativeIntegrator adds smoothness\nYou can combine multiple integrators\nGood initialization helps convergence","category":"page"},{"location":"generated/concepts/integrators/#Next-Steps","page":"Integrators","title":"Next Steps","text":"","category":"section"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"Objectives: Learn how to define cost functions\nConstraints: Add bounds and path constraints\nTutorials: See integrators in complete examples","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"","category":"page"},{"location":"generated/concepts/integrators/","page":"Integrators","title":"Integrators","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/example/#Complete-Example:-Time-Optimal-Bilinear-Control","page":"Complete Example","title":"Complete Example: Time-Optimal Bilinear Control","text":"","category":"section"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"This example demonstrates solving a time-optimal trajectory optimization problem with:","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"Multiple control inputs with bounds\nFree time steps (variable Δt)\nCombined objective (control effort + minimum time)","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"using DirectTrajOpt\nusing NamedTrajectories\nusing LinearAlgebra\nusing CairoMakie","category":"page"},{"location":"generated/example/#Problem-Setup","page":"Complete Example","title":"Problem Setup","text":"","category":"section"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"System: 3D oscillator with 2 control inputs","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"dotx = (G_0 + u_1 G_1 + u_2 G_2) x","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"Goal: Drive from [1, 0, 0] to [0, 0, 1] minimizing ∫ ||u||² dt + w·T","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"Constraints: -1 ≤ u ≤ 1, 0.05 ≤ Δt ≤ 0.3","category":"page"},{"location":"generated/example/#Define-System-Dynamics","page":"Complete Example","title":"Define System Dynamics","text":"","category":"section"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"G_drift = [\n     0.0   1.0   0.0;\n    -1.0   0.0   0.0;\n     0.0   0.0  -0.1\n]\n\nG_drives = [\n    [1.0  0.0  0.0;\n     0.0  0.0  0.0;\n     0.0  0.0  0.0],\n    [0.0  0.0  0.0;\n     0.0  0.0  1.0;\n     0.0  1.0  0.0]\n]\n\nG = u -> G_drift + sum(u .* G_drives)","category":"page"},{"location":"generated/example/#Create-Trajectory","page":"Complete Example","title":"Create Trajectory","text":"","category":"section"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"N = 50\nx_init = [1.0, 0.0, 0.0]\nx_goal = [0.0, 0.0, 1.0]\nx_guess = hcat([x_init + (x_goal - x_init) * (k/(N-1)) for k in 0:N-1]...)\n\ntraj = NamedTrajectory(\n    (\n        x = x_guess,\n        u = 0.1 * randn(2, N),\n        Δt = fill(0.15, N)\n    );\n    timestep=:Δt,\n    controls=(:u, :Δt),\n    initial=(x = x_init,),\n    final=(x = x_goal,),\n    bounds=(\n        u = 1.0,\n        Δt = (0.05, 0.3)\n    )\n)","category":"page"},{"location":"generated/example/#Build-and-Solve-Problem","page":"Complete Example","title":"Build and Solve Problem","text":"","category":"section"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"integrator = BilinearIntegrator(G, traj, :x, :u)\n\nobj = (\n    QuadraticRegularizer(:u, traj, 1.0) +\n    0.5 * MinimumTimeObjective(traj, 1.0)\n)\n\nprob = DirectTrajOptProblem(traj, obj, integrator)\nsolve!(prob; max_iter=50)","category":"page"},{"location":"generated/example/#Visualize-Solution","page":"Complete Example","title":"Visualize Solution","text":"","category":"section"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"plot(prob.trajectory) # See NamedTrajectories.jl documentation for plotting options","category":"page"},{"location":"generated/example/#Analyze-Solution","page":"Complete Example","title":"Analyze Solution","text":"","category":"section"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"x_sol = prob.trajectory.x\nu_sol = prob.trajectory.u\nΔt_sol = prob.trajectory.Δt\n\nprintln(\"Solution found!\")\nprintln(\"  Total time: $(sum(Δt_sol)) seconds\")\nprintln(\"  Δt range: [$(minimum(Δt_sol)), $(maximum(Δt_sol))]\")\nprintln(\"  Max |u₁|: $(maximum(abs.(u_sol[1,:])))\")\nprintln(\"  Max |u₂|: $(maximum(abs.(u_sol[2,:])))\")\nprintln(\"  Final error: $(norm(x_sol[:,end] - x_goal))\")","category":"page"},{"location":"generated/example/#Key-Insights","page":"Complete Example","title":"Key Insights","text":"","category":"section"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"Free time optimization: Variable Δt allows the optimizer to adjust trajectory speed, with shorter steps where control is needed and longer steps in smooth regions.","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"Control bounds: With time weight 0.5, controls don't fully saturate. Increase the weight to push toward bang-bang control.","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"Combined objectives: The + operator makes it easy to balance multiple goals.","category":"page"},{"location":"generated/example/#Exercises","page":"Complete Example","title":"Exercises","text":"","category":"section"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"1. Bang-bang control: Set time weight to 5.0 - do controls saturate the bounds?","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"2. Fixed time: Remove Δt from controls and compare total time.","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"3. Add waypoint: Require passing through [0.5, 0, 0.5] at the midpoint:","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"constraint = NonlinearKnotPointConstraint(\n    x -> x - [0.5, 0, 0.5], :x, traj;\n    times=[div(N,2)], equality=true\n)\nprob = DirectTrajOptProblem(traj, obj, integrator; constraints=[constraint])","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"4. Different goal: Try reaching [0, 1, 0] or [0.5, 0.5, 0.5]","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"5. Tighter bounds: Use bounds=(u = 0.5, Δt = (0.05, 0.3)) - how does time change?","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"","category":"page"},{"location":"generated/example/","page":"Complete Example","title":"Complete Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/concepts/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"Constraints restrict the feasible region beyond dynamics. DirectTrajOpt supports bounds, boundary conditions, and nonlinear path constraints.","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"using DirectTrajOpt\nusing NamedTrajectories\nusing LinearAlgebra\n\nN = 50\ntraj = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt, controls=:u\n)","category":"page"},{"location":"generated/concepts/constraints/#Bounds-(Cheapest)","page":"Constraints","title":"Bounds (Cheapest)","text":"","category":"section"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"Box constraints on variables:","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"traj_bounds = NamedTrajectory(\n    (x = randn(2, N), u = randn(2, N), Δt = fill(0.1, N));\n    timestep=:Δt, controls=:u,\n    bounds=(\n        x = 5.0,                          # -5 ≤ x ≤ 5\n        u = (-1.0, 2.0),                  # -1 ≤ u ≤ 2\n        Δt = (0.01, 0.5)                  # 0.01 ≤ Δt ≤ 0.5\n    )\n)","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"Per-component bounds:","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"traj_component_bounds = NamedTrajectory(\n    (x = randn(2, N), u = randn(2, N), Δt = fill(0.1, N));\n    timestep=:Δt, controls=:u,\n    bounds=(u = ([-1.0, -2.0], [1.0, 3.0]),)  # Different bounds per component\n)","category":"page"},{"location":"generated/concepts/constraints/#Nonlinear-Constraints","page":"Constraints","title":"Nonlinear Constraints","text":"","category":"section"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"Inequality: c(x, u) ≥ 0 (preferred - easier to satisfy)","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"constraint_ineq = NonlinearKnotPointConstraint(\n    u -> [1.0 - norm(u)],  # ||u|| ≤ 1\n    :u, traj; times=1:N, equality=false\n)","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"Equality: c(x, u) = 0 (more restrictive)","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"constraint_eq = NonlinearKnotPointConstraint(\n    x -> [x[1] - 0.5],  # x₁ = 0.5\n    :x, traj; times=[25], equality=true\n)","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"Multiple variables:","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"constraint_multi = NonlinearKnotPointConstraint(\n    (x, u) -> [x[1]^2 + x[2]^2 - u[1]],\n    [:x, :u], traj; equality=false\n)","category":"page"},{"location":"generated/concepts/constraints/#Common-Patterns","page":"Constraints","title":"Common Patterns","text":"","category":"section"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"Obstacle avoidance:","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"obs_center, obs_radius = [0.5, 0.5], 0.2\nconstraint_obstacle = NonlinearKnotPointConstraint(\n    x -> [norm(x - obs_center)^2 - obs_radius^2],\n    :x, traj; times=1:N, equality=false\n)","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"Multiple obstacles:","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"constraints_obstacles = [\n    NonlinearKnotPointConstraint(\n        x -> [norm(x - center)^2 - radius^2],\n        :x, traj; equality=false\n    )\n    for (center, radius) in [([0.3, 0.3], 0.15), ([0.7, 0.7], 0.15)]\n]","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"State-dependent control limits:","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"constraint_state_dep = NonlinearKnotPointConstraint(\n    (x, u) -> [1.0 - u[1] / (1.0 + abs(x[1]))],\n    [:x, :u], traj; equality=false\n)","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"Energy constraints:","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"E_max = 2.0\nconstraint_energy = NonlinearKnotPointConstraint(\n    (x, u) -> [E_max - (0.5 * norm(x)^2 + 0.5 * norm(u)^2)],\n    [:x, :u], traj; equality=false\n)","category":"page"},{"location":"generated/concepts/constraints/#Time-Selection","page":"Constraints","title":"Time Selection","text":"","category":"section"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"All times, specific times, or ranges:","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"constraint_all = NonlinearKnotPointConstraint(\n    u -> [1.0 - norm(u)], :u, traj; times=1:N, equality=false\n)\n\nconstraint_specific = NonlinearKnotPointConstraint(\n    x -> [x[1]^2 + x[2]^2 - 1.0], :x, traj;\n    times=[1, 10, 20, 30, 40, 50], equality=false\n)\n\nconstraint_range = NonlinearKnotPointConstraint(\n    u -> [0.5 - norm(u)], :u, traj; times=10:40, equality=false\n)","category":"page"},{"location":"generated/concepts/constraints/#Creating-a-Problem","page":"Constraints","title":"Creating a Problem","text":"","category":"section"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"G_drift = [-0.1 1.0; -1.0 -0.1]\nG_drives = [[0.0 1.0; 1.0 0.0]]\nG = u -> G_drift + sum(u .* G_drives)\nintegrator = BilinearIntegrator(G, traj, :x, :u)\nobj = QuadraticRegularizer(:u, traj, 1.0)\n\nconstraints = [constraint_obstacle, constraint_ineq]\nprob = DirectTrajOptProblem(traj, obj, integrator; constraints=constraints)","category":"page"},{"location":"generated/concepts/constraints/#Summary","page":"Constraints","title":"Summary","text":"","category":"section"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"Constraint Type Form Cost Use Case\nBounds l ≤ v ≤ u Very cheap Physical limits\nDynamics xₖ₊₁ = Φ(xₖ, uₖ) Moderate System evolution\nBoundary x₁ = x₀, xₖ = xf Cheap Initial/final states\nNonlinear inequality c(x, u) ≥ 0 Moderate Obstacles, limits\nNonlinear equality c(x, u) = 0 Expensive Exact requirements","category":"page"},{"location":"generated/concepts/constraints/#Performance-Tips","page":"Constraints","title":"Performance Tips","text":"","category":"section"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"Recommendation Rationale\nUse bounds over nonlinear constraints Much faster to evaluate\nPrefer inequalities over equalities Easier to satisfy, larger feasible region\nScale constraint values to O(1) Better numerical conditioning\nAdd constraints incrementally Easier to debug, avoids over-constraining\nCheck initial guess feasibility Prevents infeasible starts","category":"page"},{"location":"generated/concepts/constraints/#Troubleshooting","page":"Constraints","title":"Troubleshooting","text":"","category":"section"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"If optimizer struggles:","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"Infeasible start: Initial guess violates constraints → improve initial guess\nOver-constrained: Too many/conflicting constraints → relax or remove some\nPoorly scaled: Values span many orders of magnitude → rescale to O(1)\nTight constraints: Little feasible space → relax bounds or use soft constraints","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"","category":"page"},{"location":"generated/concepts/constraints/","page":"Constraints","title":"Constraints","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/concepts/objectives/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"generated/concepts/objectives/#What-are-Objectives?","page":"Objectives","title":"What are Objectives?","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Objectives (or cost functions) define what you want to minimize in your optimization problem. DirectTrajOpt.jl uses an additive structure where you can combine multiple objective terms:","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"J_texttotal = w_1 J_1 + w_2 J_2 + cdots + w_N J_N","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"using DirectTrajOpt\nusing NamedTrajectories\nusing LinearAlgebra","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Setup a sample trajectory for examples","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"N = 50\ntraj = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = [0.0, 0.0],),\n    goal=(x = [1.0, 0.0],)\n)","category":"page"},{"location":"generated/concepts/objectives/#QuadraticRegularizer","page":"Objectives","title":"QuadraticRegularizer","text":"","category":"section"},{"location":"generated/concepts/objectives/#Overview","page":"Objectives","title":"Overview","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Penalizes the squared norm of a variable:","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"J = sum_k=1^N v_k^2","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"This is the most common objective for regularization.","category":"page"},{"location":"generated/concepts/objectives/#Control-Effort-Regularization","page":"Objectives","title":"Control Effort Regularization","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_u = QuadraticRegularizer(:u, traj, 1.0)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Minimizes: Σₖ ||uₖ||²","category":"page"},{"location":"generated/concepts/objectives/#State-Regularization","page":"Objectives","title":"State Regularization","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_x = QuadraticRegularizer(:x, traj, 0.1)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Minimizes: 0.1 * Σₖ ||xₖ||²","category":"page"},{"location":"generated/concepts/objectives/#Control-Derivative-Regularization-(Smoothness)","page":"Objectives","title":"Control Derivative Regularization (Smoothness)","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"traj_smooth = NamedTrajectory(\n    (x = randn(2, N), u = randn(2, N), du = zeros(2, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u\n)\n\nobj_du = QuadraticRegularizer(:du, traj_smooth, 1.0)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Minimizes: Σₖ ||duₖ||² (encourages smooth controls)","category":"page"},{"location":"generated/concepts/objectives/#Combining-Regularizers","page":"Objectives","title":"Combining Regularizers","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Typical combination: control effort + smoothness","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_combined = QuadraticRegularizer(:u, traj_smooth, 1e-2) +\n               QuadraticRegularizer(:du, traj_smooth, 1e-1)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Small control penalty, larger smoothness penalty","category":"page"},{"location":"generated/concepts/objectives/#Per-Component-Weights","page":"Objectives","title":"Per-Component Weights","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"You can weight each component differently:","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_weighted = QuadraticRegularizer(:u, traj_smooth, [1.0, 0.5])","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"First control component weighted more heavily","category":"page"},{"location":"generated/concepts/objectives/#MinimumTimeObjective","page":"Objectives","title":"MinimumTimeObjective","text":"","category":"section"},{"location":"generated/concepts/objectives/#Overview-2","page":"Objectives","title":"Overview","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Minimizes the total trajectory duration:","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"J = w sum_k=1^N Delta t_k","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"This encourages fast trajectories.","category":"page"},{"location":"generated/concepts/objectives/#Basic-Usage","page":"Objectives","title":"Basic Usage","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_time = MinimumTimeObjective(traj, 0.1)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Minimizes: 0.1 * Σₖ Δtₖ","category":"page"},{"location":"generated/concepts/objectives/#Time-Energy-Tradeoff","page":"Objectives","title":"Time-Energy Tradeoff","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Combine with control regularization to trade off speed vs effort:","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_tradeoff = QuadraticRegularizer(:u, traj, 1.0) +\n               MinimumTimeObjective(traj, 0.5)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Higher time weight → faster but more control effort Lower time weight → slower but less control effort","category":"page"},{"location":"generated/concepts/objectives/#Free-Time-Problems","page":"Objectives","title":"Free Time Problems","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"traj_free_time = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    bounds=(Δt = (0.01, 0.5),)  # Allow variable time steps\n)\n\nobj_free_time = QuadraticRegularizer(:u, traj_free_time, 1.0) +\n                MinimumTimeObjective(traj_free_time, 1.0)","category":"page"},{"location":"generated/concepts/objectives/#TerminalObjective","page":"Objectives","title":"TerminalObjective","text":"","category":"section"},{"location":"generated/concepts/objectives/#Overview-3","page":"Objectives","title":"Overview","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Applies a cost only at the final time step:","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"J = f(x_N)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Useful for soft constraints on the final state.","category":"page"},{"location":"generated/concepts/objectives/#Distance-to-Goal","page":"Objectives","title":"Distance to Goal","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"x_goal = [1.0, 0.0]\nobj_terminal = TerminalObjective(\n    x -> norm(x - x_goal)^2,\n    :x,\n    traj\n)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Penalizes: ||xN - xgoal||²","category":"page"},{"location":"generated/concepts/objectives/#Custom-Terminal-Cost","page":"Objectives","title":"Custom Terminal Cost","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Any function of the final state:","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_custom_terminal = TerminalObjective(\n    x -> x[1]^2 + 2*x[2]^2 + x[1]*x[2],\n    :x,\n    traj\n)","category":"page"},{"location":"generated/concepts/objectives/#When-to-Use","page":"Objectives","title":"When to Use","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Soft goal: Don't enforce exact final state, just penalize deviation\nMultiple goals: Can have terminal costs on multiple variables\nCustom metrics: Use domain-specific final state metrics","category":"page"},{"location":"generated/concepts/objectives/#Hard-vs-Soft-Constraints","page":"Objectives","title":"Hard vs Soft Constraints","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Hard constraint (via trajectory):","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"traj_hard = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    final=(x = x_goal,)  # Exact constraint\n)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Soft constraint (via terminal objective):","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"traj_soft = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    goal=(x = x_goal,)  # For reference only\n)\nobj_soft = TerminalObjective(x -> 100.0 * norm(x - x_goal)^2, :x, traj_soft)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Large weight approximates hard constraint","category":"page"},{"location":"generated/concepts/objectives/#KnotPointObjective","page":"Objectives","title":"KnotPointObjective","text":"","category":"section"},{"location":"generated/concepts/objectives/#Overview-4","page":"Objectives","title":"Overview","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Applies a cost at specific time steps:","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"J = sum_k in K f(x_k u_k)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Useful for waypoints or intermediate constraints.","category":"page"},{"location":"generated/concepts/objectives/#Single-Time-Point","page":"Objectives","title":"Single Time Point","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_knot_single = KnotPointObjective(\n    (x, u) -> norm(x - [0.5, 0.5])^2,\n    [:x, :u],\n    traj;\n    times=[25]  # Only at k=25\n)","category":"page"},{"location":"generated/concepts/objectives/#Multiple-Time-Points","page":"Objectives","title":"Multiple Time Points","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_knot_multi = KnotPointObjective(\n    (x, u) -> norm(u)^2,\n    [:x, :u],\n    traj;\n    times=[10, 20, 30, 40]  # At k=10, 20, 30, 40\n)","category":"page"},{"location":"generated/concepts/objectives/#All-Time-Points-(Path-Cost)","page":"Objectives","title":"All Time Points (Path Cost)","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_knot_all = KnotPointObjective(\n    (x, u) -> x[1]^2 + u[1]^2,\n    [:x, :u],\n    traj;\n    times=1:N  # All time steps\n)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Equivalent to manually summing costs","category":"page"},{"location":"generated/concepts/objectives/#Waypoint-Tracking","page":"Objectives","title":"Waypoint Tracking","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"waypoints = [\n    [0.25, 0.25],  # k=13\n    [0.75, 0.75],  # k=38\n]\nwaypoint_times = [13, 38]\n\nobj_waypoints = sum(\n    KnotPointObjective(\n        (x, u) -> 10.0 * norm(x - wp)^2,\n        [:x, :u],\n        traj;\n        times=[t]\n    )\n    for (wp, t) in zip(waypoints, waypoint_times)\n)","category":"page"},{"location":"generated/concepts/objectives/#GlobalObjective","page":"Objectives","title":"GlobalObjective","text":"","category":"section"},{"location":"generated/concepts/objectives/#Overview-5","page":"Objectives","title":"Overview","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Applies a cost to global variables (constants across time):","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"J = f(g)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Useful for parameters, scaling factors, or other time-independent variables.","category":"page"},{"location":"generated/concepts/objectives/#Example-with-Global-Parameter","page":"Objectives","title":"Example with Global Parameter","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"traj_global = NamedTrajectory(\n    (\n        x = randn(2, N),\n        u = randn(1, N),\n        Δt = fill(0.1, N)\n    );\n    timestep=:Δt,\n    controls=:u,\n    global_data=[1.0],  # Global parameter\n    global_components=(α = 1:1,)\n)\n\nobj_global = GlobalObjective(\n    α -> (α[1] - 2.0)^2,  # Penalize α deviating from 2\n    :α,\n    traj_global\n)","category":"page"},{"location":"generated/concepts/objectives/#Combining-Objectives","page":"Objectives","title":"Combining Objectives","text":"","category":"section"},{"location":"generated/concepts/objectives/#Addition-Operator","page":"Objectives","title":"Addition Operator","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"The + operator combines objectives:","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj1 = QuadraticRegularizer(:u, traj, 1.0)\nobj2 = MinimumTimeObjective(traj, 0.1)\nobj3 = TerminalObjective(x -> norm(x - x_goal)^2, :x, traj)\n\nobj_total = obj1 + obj2 + obj3","category":"page"},{"location":"generated/concepts/objectives/#Weighting-Strategy","page":"Objectives","title":"Weighting Strategy","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Common pattern: regularization + task objective + time","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_pattern = (\n    1e-2 * QuadraticRegularizer(:u, traj, 1.0) +      # Small control penalty\n    1e-1 * MinimumTimeObjective(traj, 1.0) +          # Moderate time penalty\n    1e2 * TerminalObjective(                          # Large goal penalty\n        x -> norm(x - x_goal)^2, :x, traj\n    )\n)","category":"page"},{"location":"generated/concepts/objectives/#Building-Incrementally","page":"Objectives","title":"Building Incrementally","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_build = QuadraticRegularizer(:u, traj, 1.0)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Add time minimization","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_build += MinimumTimeObjective(traj, 0.1)","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Add terminal cost","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_build += TerminalObjective(x -> norm(x - x_goal)^2, :x, traj)","category":"page"},{"location":"generated/concepts/objectives/#Objective-Design-Patterns","page":"Objectives","title":"Objective Design Patterns","text":"","category":"section"},{"location":"generated/concepts/objectives/#Pattern-1:-Pure-Tracking","page":"Objectives","title":"Pattern 1: Pure Tracking","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Minimize deviation from goal at final time","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_tracking = TerminalObjective(x -> norm(x - x_goal)^2, :x, traj)","category":"page"},{"location":"generated/concepts/objectives/#Pattern-2:-Energy-Optimal","page":"Objectives","title":"Pattern 2: Energy-Optimal","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Minimize control effort with soft goal","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_energy = (\n    QuadraticRegularizer(:u, traj, 1.0) +\n    10.0 * TerminalObjective(x -> norm(x - x_goal)^2, :x, traj)\n)","category":"page"},{"location":"generated/concepts/objectives/#Pattern-3:-Minimum-Time","page":"Objectives","title":"Pattern 3: Minimum-Time","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Fast trajectories with bounded controls","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"traj_mintime = NamedTrajectory(\n    (x = randn(2, N), u = randn(1, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    bounds=(u = 1.0, Δt = (0.01, 0.5))\n)\n\nobj_mintime = (\n    1e-3 * QuadraticRegularizer(:u, traj_mintime, 1.0) +  # Small regularization\n    1.0 * MinimumTimeObjective(traj_mintime, 1.0) +       # Minimize time\n    100.0 * TerminalObjective(                            # Strong goal\n        x -> norm(x - x_goal)^2, :x, traj_mintime\n    )\n)","category":"page"},{"location":"generated/concepts/objectives/#Pattern-4:-Smooth-Control","page":"Objectives","title":"Pattern 4: Smooth Control","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Implementable controls with derivative penalties","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"traj_smooth_obj = NamedTrajectory(\n    (x = randn(2, N), u = randn(2, N), du = zeros(2, N), Δt = fill(0.1, N));\n    timestep=:Δt,\n    controls=:u,\n    initial=(u = [0.0, 0.0],),\n    final=(u = [0.0, 0.0],)\n)\n\nobj_smooth_pattern = (\n    1e-2 * QuadraticRegularizer(:u, traj_smooth_obj, 1.0) +   # Control effort\n    1e-1 * QuadraticRegularizer(:du, traj_smooth_obj, 1.0) +  # Smoothness\n    10.0 * TerminalObjective(x -> norm(x - x_goal)^2, :x, traj_smooth_obj)\n)","category":"page"},{"location":"generated/concepts/objectives/#Pattern-5:-Waypoint-Following","page":"Objectives","title":"Pattern 5: Waypoint Following","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Hit intermediate points along trajectory","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"obj_waypoint_pattern = (\n    QuadraticRegularizer(:u, traj, 1.0) +\n    obj_waypoints +  # From earlier example\n    TerminalObjective(x -> norm(x - x_goal)^2, :x, traj)\n)","category":"page"},{"location":"generated/concepts/objectives/#Weight-Tuning-Guidelines","page":"Objectives","title":"Weight Tuning Guidelines","text":"","category":"section"},{"location":"generated/concepts/objectives/#Relative-Magnitudes","page":"Objectives","title":"Relative Magnitudes","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Regularization: 1e-3 to 1e-1 (small, for smoothness/stability)\nTask objectives: 1e0 to 1e2 (primary goal)\nHard constraints via penalties: 1e2 to 1e4 (large, approximate hard constraints)","category":"page"},{"location":"generated/concepts/objectives/#Balancing-Tradeoffs","page":"Objectives","title":"Balancing Tradeoffs","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"# Fast, aggressive controls\nobj = 1e-4 * QuadraticRegularizer(:u, traj, 1.0) + MinimumTimeObjective(traj, 1.0)\n\n# Slow, gentle controls\nobj = 1e0 * QuadraticRegularizer(:u, traj, 1.0) + 1e-2 * MinimumTimeObjective(traj, 1.0)","category":"page"},{"location":"generated/concepts/objectives/#Iterative-Tuning","page":"Objectives","title":"Iterative Tuning","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Start with task objective only\nAdd regularization if needed for stability\nAdjust weights based on results\nUse solver output to guide adjustments","category":"page"},{"location":"generated/concepts/objectives/#Custom-Objectives","page":"Objectives","title":"Custom Objectives","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"You can create custom objectives by implementing the Objective interface. All objectives must define how they contribute to the cost and its gradients.","category":"page"},{"location":"generated/concepts/objectives/#Example-Structure-(Conceptual)","page":"Objectives","title":"Example Structure (Conceptual)","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"# Custom objective for special cost\nmy_obj = CustomObjective(params...)\n\n# Add to problem\nobj = QuadraticRegularizer(:u, traj, 1.0) + my_obj","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"See the API Reference for details on implementing custom objectives.","category":"page"},{"location":"generated/concepts/objectives/#Summary","page":"Objectives","title":"Summary","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Objective Type Use Case Typical Weight\nQuadraticRegularizer Control effort, smoothness 1e-3 to 1e-1\nMinimumTimeObjective Fast trajectories 1e-2 to 1e0\nTerminalObjective Goal reaching 1e0 to 1e2\nKnotPointObjective Waypoints, path costs 1e0 to 1e1\nGlobalObjective Parameter penalties Problem-specific","category":"page"},{"location":"generated/concepts/objectives/#Best-Practices","page":"Objectives","title":"Best Practices","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Start simple: Use basic regularization + terminal cost first\nScale consistently: Keep objective terms of similar magnitude\nUse soft constraints: Prefer high-weight objectives over hard constraints when possible\nMonitor convergence: Check if optimizer struggles with certain objectives\nIterative refinement: Adjust weights based on results","category":"page"},{"location":"generated/concepts/objectives/#Next-Steps","page":"Objectives","title":"Next Steps","text":"","category":"section"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"Constraints: Learn about bounds and path constraints\nTutorials: See complete examples with combined objectives\nProblem Setup: Put it all together to solve optimization problems","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"","category":"page"},{"location":"generated/concepts/objectives/","page":"Objectives","title":"Objectives","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quickstart/#Quickstart-Guide","page":"Quickstart","title":"Quickstart Guide","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Welcome to DirectTrajOpt.jl! This guide will get you up and running in minutes.","category":"page"},{"location":"generated/quickstart/#What-is-DirectTrajOpt?","page":"Quickstart","title":"What is DirectTrajOpt?","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"DirectTrajOpt.jl solves trajectory optimization problems - finding optimal control sequences that drive a dynamical system from an initial state to a goal state while minimizing a cost function.","category":"page"},{"location":"generated/quickstart/#Installation","page":"Quickstart","title":"Installation","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"First, install the package:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"using Pkg\nPkg.add(\"DirectTrajOpt\")","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"You'll also need NamedTrajectories.jl for defining trajectories:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"using DirectTrajOpt\nusing NamedTrajectories\nusing LinearAlgebra\nusing CairoMakie","category":"page"},{"location":"generated/quickstart/#A-Minimal-Example","page":"Quickstart","title":"A Minimal Example","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Let's solve a simple problem: drive a 2D system from [0, 0] to [1, 0] with minimal control effort.","category":"page"},{"location":"generated/quickstart/#Step-1:-Define-the-Trajectory","page":"Quickstart","title":"Step 1: Define the Trajectory","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"A trajectory contains your states, controls, and time information:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"N = 50  # number of time steps\ntraj = NamedTrajectory(\n    (\n        x = randn(2, N),    # 2D state\n        u = randn(1, N),    # 1D control\n        Δt = fill(0.1, N)   # time step\n    );\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = [0.0, 0.0],),\n    final=(x = [1.0, 0.0],),\n    bounds=(Δt = (0.05, 0.2), u = 1.0)\n)","category":"page"},{"location":"generated/quickstart/#Step-2:-Define-the-Dynamics","page":"Quickstart","title":"Step 2: Define the Dynamics","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Specify how your system evolves. For bilinear dynamics ẋ = (G₀ + u₁G₁) x:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"G_drift = [-0.1 1.0; -1.0 -0.1]   # drift term\nG_drives = [[0.0 1.0; 1.0 0.0]]   # control term\nG = u -> G_drift + sum(u .* G_drives)\n\nintegrator = BilinearIntegrator(G, traj, :x, :u)","category":"page"},{"location":"generated/quickstart/#Step-3:-Define-the-Objective","page":"Quickstart","title":"Step 3: Define the Objective","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"What do we want to minimize? Let's penalize control effort:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"obj = QuadraticRegularizer(:u, traj, 1.0)","category":"page"},{"location":"generated/quickstart/#Step-4:-Create-and-Solve","page":"Quickstart","title":"Step 4: Create and Solve","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Combine everything into a problem and solve:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"prob = DirectTrajOptProblem(traj, obj, integrator)\nsolve!(prob; max_iter=100, verbose=false)","category":"page"},{"location":"generated/quickstart/#Step-5:-Access-the-Solution","page":"Quickstart","title":"Step 5: Access the Solution","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Let's look at the results.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"plot(prob.trajectory)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"The optimized trajectory is stored in prob.trajectory:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"println(\"Final state: \", prob.trajectory.x[:, end])\nprintln(\"Control norm: \", norm(prob.trajectory.u))","category":"page"},{"location":"generated/quickstart/#What-You-Can-Do","page":"Quickstart","title":"What You Can Do","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Multiple objectives: Combine regularization, minimum time, terminal costs\nFlexible dynamics: Linear, bilinear, time-dependent systems\nAdd constraints: Bounds, path constraints, custom nonlinear constraints\nSmooth controls: Penalize derivatives for smooth, implementable controls\nFree time: Optimize trajectory duration","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#DirectTrajOpt.jl","page":"Home","title":"DirectTrajOpt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<!-- <div align=\"center\">\n  <a href=\"https://github.com/harmoniqs/Piccolo.jl\">\n    <img src=\"assets/logo.svg\" alt=\"Piccolo.jl\" width=\"25%\"/>\n  </a>\n</div> -->\n\n<div align=\"center\">\n  <table>\n    <tr>\n      <td align=\"center\">\n        <b>Documentation</b>\n        <br>\n        <a href=\"https://docs.harmoniqs.co/DirectTrajOpt/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\" alt=\"Stable\"/>\n        </a>\n        <a href=\"https://docs.harmoniqs.co/DirectTrajOpt/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-dev-blue.svg\" alt=\"Dev\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Build Status</b>\n        <br>\n        <a href=\"https://github.com/harmoniqs/DirectTrajOpt.jl/actions/workflows/CI.yml?query=branch%3Amain\">\n          <img src=\"https://github.com/harmoniqs/DirectTrajOpt.jl/actions/workflows/CI.yml/badge.svg?branch=main\" alt=\"Build Status\"/>\n        </a>\n        <a href=\"https://codecov.io/gh/harmoniqs/DirectTrajOpt.jl\">\n          <img src=\"https://codecov.io/gh/harmoniqs/DirectTrajOpt.jl/branch/main/graph/badge.svg\" alt=\"Coverage\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>License</b>\n        <br>\n        <a href=\"https://opensource.org/licenses/MIT\">\n          <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"MIT License\"/>\n        </a>\n    </tr>\n  </table>\n</div>\n\n<div align=\"center\">\n<br>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"DirectTrajOpt.jl provides a framework for setting up and solving direct trajectory optimization problems using nonlinear programming.","category":"page"},{"location":"#Problem-Formulation","page":"Home","title":"Problem Formulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DirectTrajOpt solves problems of the form:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\nundersetx_1N u_1Ntextminimize quad  J(x_1N u_1N) \ntextsubject to quad  f(x_k+1 x_k u_k Delta t t_k) = 0 quad k = 1 ldots N-1\n c_k(x_k u_k) geq 0 quad k = 1 ldots N \n x_1 = x_textinit quad x_N = x_textgoal \nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"where:","category":"page"},{"location":"","page":"Home","title":"Home","text":"J(x, u) is the objective function to minimize\nf(·) represents system dynamics encoded via integrators\nc(·) represents additional nonlinear constraints\nx is the state trajectory\nu is the control trajectory","category":"page"},{"location":"","page":"Home","title":"Home","text":"The underlying nonlinear solver is Ipopt.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DirectTrajOpt\")","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using DirectTrajOpt\nusing NamedTrajectories\n\n# Define trajectory\ntraj = NamedTrajectory(\n    (x = randn(2, 50), u = randn(1, 50), Δt = fill(0.1, 50));\n    timestep=:Δt,\n    controls=:u,\n    initial=(x = [0.0, 0.0],),\n    final=(x = [1.0, 0.0],)\n)\n\n# Define dynamics\nA = [-0.1 1.0; -1.0 -0.1]\nB = reshape([0.0, 1.0], 2, 1)\nintegrator = BilinearIntegrator([A B], traj, :x, :u)\n\n# Define objective\nobj = QuadraticRegularizer(:u, traj, 1.0)\n\n# Create and solve problem\nprob = DirectTrajOptProblem(traj, obj, integrator)\nsolve!(prob; max_iter=100)","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flexible dynamics: Define system evolution via integrators\nModular objectives: Combine multiple cost terms (regularization, minimum time, etc.)\nConstraint support: Bounds, equality, and general nonlinear constraints  \nAutomatic differentiation: Efficient gradients and Hessians\nSparse formulations: Exploits problem structure for efficiency ","category":"page"},{"location":"#Building-Documentation","page":"Home","title":"Building Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"# first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/","category":"page"},{"location":"","page":"Home","title":"Home","text":"To build the docs pages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs docs/make.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"or editing the docs live:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: servedocs needs to watch a subset of the files in the docs/ folder. If it watches files that are generated on a docs build/re-build, servedocs will continuously try to re-serve the pages.To prevent this, ensure all generated files are included in the skip dirs or skip files args for servedocs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, if we forget index.md like so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"it will not build and serve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to take away.\" - Antoine de Saint-Exupéry","category":"page"}]
}
