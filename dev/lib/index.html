<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · DirectTrajOpt.jl</title><meta name="title" content="Library · DirectTrajOpt.jl"/><meta property="og:title" content="Library · DirectTrajOpt.jl"/><meta property="twitter:title" content="Library · DirectTrajOpt.jl"/><meta name="description" content="Documentation for DirectTrajOpt.jl."/><meta property="og:description" content="Documentation for DirectTrajOpt.jl."/><meta property="twitter:description" content="Documentation for DirectTrajOpt.jl."/><meta property="og:url" content="https://docs.harmoniqs.co/DirectTrajOpt.jl/lib/"/><meta property="twitter:url" content="https://docs.harmoniqs.co/DirectTrajOpt.jl/lib/"/><link rel="canonical" href="https://docs.harmoniqs.co/DirectTrajOpt.jl/lib/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="DirectTrajOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DirectTrajOpt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../generated/quickstart/">Quickstart</a></li><li><a class="tocitem" href="../generated/example/">Complete Example</a></li></ul></li><li><span class="tocitem">Core Concepts</span><ul><li><a class="tocitem" href="../generated/concepts/problem_formulation/">Problem Formulation</a></li><li><a class="tocitem" href="../generated/concepts/trajectories/">Trajectories</a></li><li><a class="tocitem" href="../generated/concepts/integrators/">Integrators</a></li><li><a class="tocitem" href="../generated/concepts/objectives/">Objectives</a></li><li><a class="tocitem" href="../generated/concepts/constraints/">Constraints</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../generated/tutorials/linear_system/">Linear System</a></li><li><a class="tocitem" href="../generated/tutorials/bilinear_control/">Bilinear Control</a></li><li><a class="tocitem" href="../generated/tutorials/minimum_time/">Minimum Time</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Common-Interface"><span>Common Interface</span></a></li><li><a class="tocitem" href="#Constraints"><span>Constraints</span></a></li><li><a class="tocitem" href="#Integrators"><span>Integrators</span></a></li><li><a class="tocitem" href="#Objectives"><span>Objectives</span></a></li><li><a class="tocitem" href="#Problems"><span>Problems</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#Ipopt-Solver"><span>Ipopt Solver</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/harmoniqs/DirectTrajOpt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/main/docs/src/lib.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Common-Interface"><a class="docs-heading-anchor" href="#Common-Interface">Common Interface</a><a id="Common-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Interface" title="Permalink"></a></h2><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface"><code>DirectTrajOpt.CommonInterface</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>Common interface for components (integrators and constraints).</p><p>This module defines the generic interface functions that both integrators and constraints implement through multiple dispatch. This avoids naming conflicts when both modules are imported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/common_interface.jl#L1-L7">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.eval_hessian_of_lagrangian"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.eval_hessian_of_lagrangian"><code>DirectTrajOpt.CommonInterface.eval_hessian_of_lagrangian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eval_hessian_of_lagrangian(component, traj::NamedTrajectory, μ::AbstractVector)</code></pre><p>High-level method to evaluate and return the full Hessian of the Lagrangian for the component.</p><p>For integrators: Computes the Hessian using ForwardDiff across all timesteps. For constraints: Calls hessian<em>of</em>lagrangian to fill compact storage, then assembles the full sparse Hessian.</p><p><strong>Arguments</strong></p><ul><li><code>component</code>: An integrator or constraint</li><li><code>traj</code>: The trajectory providing values and structure</li><li><code>μ</code>: Lagrange multipliers</li></ul><p><strong>Returns</strong></p><ul><li>A sparse matrix representing the full Hessian μ&#39;∇²f</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/common_interface.jl#L127-L142">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.eval_jacobian"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.eval_jacobian"><code>DirectTrajOpt.CommonInterface.eval_jacobian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eval_jacobian(component, traj::NamedTrajectory)</code></pre><p>High-level method to evaluate and return the full Jacobian for the component.</p><p>For integrators: Computes the Jacobian using ForwardDiff across all timesteps. For constraints: Calls jacobian! to fill compact storage, then assembles the full sparse Jacobian.</p><p><strong>Arguments</strong></p><ul><li><code>component</code>: An integrator or constraint</li><li><code>traj</code>: The trajectory providing values and structure</li></ul><p><strong>Returns</strong></p><ul><li>A sparse matrix representing the full Jacobian</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/common_interface.jl#L110-L124">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.evaluate!"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.evaluate!"><code>DirectTrajOpt.CommonInterface.evaluate!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">evaluate!(values, component, traj::NamedTrajectory)</code></pre><p>Evaluate the component (constraint or dynamics) and store the result in-place in <code>values</code>.</p><p>For integrators: Computes dynamics violations δ = f(x<em>{k+1}, x</em>k, u_k, ...) for all timesteps. For constraints: Computes constraint violations g(x) for all applicable timesteps/variables.</p><p><strong>Arguments</strong></p><ul><li><code>values</code>: Pre-allocated vector to store the evaluation results</li><li><code>component</code>: An integrator or constraint</li><li><code>traj</code>: The trajectory providing values and structure</li></ul><p><strong>Returns</strong></p><ul><li>Nothing (modifies <code>values</code> in-place)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/common_interface.jl#L22-L37">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.hessian_of_lagrangian"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.hessian_of_lagrangian"><code>DirectTrajOpt.CommonInterface.hessian_of_lagrangian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hessian_of_lagrangian(component, μ, args...)</code></pre><p>Compute the Hessian of the Lagrangian (weighted by multipliers μ) for the component.</p><p><strong>Arguments</strong></p><ul><li><code>component</code>: An integrator, constraint, or other component</li><li><code>μ</code>: Lagrange multipliers</li><li><code>args...</code>: Component-specific arguments (e.g., knot points, trajectory values)</li></ul><p><strong>Returns</strong></p><ul><li>A sparse matrix representing μ&#39;∇²f</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/common_interface.jl#L82-L94">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.hessian_of_lagrangian!"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.hessian_of_lagrangian!"><code>DirectTrajOpt.CommonInterface.hessian_of_lagrangian!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hessian_of_lagrangian!(μ∂²f, component, μ, args...)</code></pre><p>Compute the Hessian of the Lagrangian in-place, storing the result in μ∂²f.</p><p><strong>Arguments</strong></p><ul><li><code>μ∂²f</code>: Pre-allocated sparse matrix for the Hessian</li><li><code>component</code>: An integrator, constraint, or other component</li><li><code>μ</code>: Lagrange multipliers</li><li><code>args...</code>: Component-specific arguments (e.g., knot points, trajectory values)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/common_interface.jl#L97-L107">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.hessian_structure"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.hessian_structure"><code>DirectTrajOpt.CommonInterface.hessian_structure</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hessian_structure(component, traj::NamedTrajectory)</code></pre><p>Return the sparsity structure of the Hessian of the Lagrangian for the given component.</p><p><strong>Arguments</strong></p><ul><li><code>component</code>: An integrator, constraint, or other component</li><li><code>traj</code>: The trajectory providing dimension information</li></ul><p><strong>Returns</strong></p><ul><li>A sparse matrix representing the Hessian structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/common_interface.jl#L68-L79">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.jacobian!"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.jacobian!"><code>DirectTrajOpt.CommonInterface.jacobian!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jacobian!(∂f, component, args...)</code></pre><p>Compute the Jacobian of the component in-place, storing the result in ∂f.</p><p><strong>Arguments</strong></p><ul><li><code>∂f</code>: Pre-allocated sparse matrix for the Jacobian</li><li><code>component</code>: An integrator, constraint, or other component  </li><li><code>args...</code>: Component-specific arguments (e.g., knot points, trajectory values)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/common_interface.jl#L56-L65">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.jacobian_structure"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.jacobian_structure"><code>DirectTrajOpt.CommonInterface.jacobian_structure</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jacobian_structure(component, traj::NamedTrajectory)</code></pre><p>Return the sparsity structure of the Jacobian for the given component. This should return a sparse matrix with the same structure as the Jacobian, where non-zero entries indicate where partial derivatives exist.</p><p><strong>Arguments</strong></p><ul><li><code>component</code>: An integrator, constraint, or other component</li><li><code>traj</code>: The trajectory providing dimension information</li></ul><p><strong>Returns</strong></p><ul><li>A sparse matrix representing the Jacobian structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/common_interface.jl#L40-L53">source</a></section></details></article><h2 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h2><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.AbstractConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.AbstractConstraint"><code>DirectTrajOpt.Constraints.AbstractConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractConstraint</code></pre><p>Abstract supertype for all constraints in a trajectory optimization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/_constraints.jl#L39-L43">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.AbstractLinearConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.AbstractLinearConstraint"><code>DirectTrajOpt.Constraints.AbstractLinearConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractLinearConstraint &lt;: AbstractConstraint</code></pre><p>Abstract type for linear constraints (bounds, equality, symmetry, etc.). Linear constraints are applied directly to the optimizer via MathOptInterface rather than through the NLP evaluator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/_constraints.jl#L46-L52">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.AbstractNonlinearConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.AbstractNonlinearConstraint"><code>DirectTrajOpt.Constraints.AbstractNonlinearConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractNonlinearConstraint &lt;: AbstractConstraint</code></pre><p>Abstract type for nonlinear constraints evaluated at each solver iteration.</p><p>Subtypes must implement the <a href="#DirectTrajOpt.CommonInterface"><code>CommonInterface</code></a> methods and have a <code>dim::Int</code> field giving the total constraint dimension, plus an <code>equality::Bool</code> field indicating whether the constraint is <code>g(x) = 0</code> (equality) or <code>g(x) ≤ 0</code> (inequality).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/_constraints.jl#L55-L63">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.AllEqualConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.AllEqualConstraint"><code>DirectTrajOpt.Constraints.AllEqualConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct AllEqualConstraint &lt;: AbstractLinearConstraint</code></pre><p>Constraint that all components of a variable should be equal to each other. Commonly used for fixed timesteps.</p><p><strong>Fields</strong></p><ul><li><code>var_name::Symbol</code>: Variable name to constrain</li><li><code>component_index::Int</code>: Which component of the variable (1 for scalar variables)</li><li><code>label::String</code>: Constraint label</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/all_equal_constraint.jl#L4-L14">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.BoundsConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.BoundsConstraint"><code>DirectTrajOpt.Constraints.BoundsConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct BoundsConstraint &lt;: AbstractLinearConstraint</code></pre><p>Represents a box constraint defined by variable names. Indices and concrete bounds are computed in constrain!.</p><p><strong>Fields</strong></p><ul><li><code>var_names::Union{Symbol, Vector{Symbol}}</code>: Variable name(s) to constrain</li><li><code>times::Union{Nothing, Vector{Int}}</code>: Time indices (nothing for global variables)</li><li><code>bounds_values::Union{Float64, Vector{Float64}, Tuple{Vector{Float64}, Vector{Float64}}}</code>: Bound specification</li><li><code>is_global::Bool</code>: Whether this is a global variable constraint</li><li><code>subcomponents::Union{Nothing, UnitRange{Int}}</code>: Optional subcomponent selection</li><li><code>label::String</code>: Constraint label</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/bounds_constraint.jl#L8-L21">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.BoundsConstraint-Tuple{Symbol, AbstractVector{Int64}, Union{Float64, Tuple{Vector{Float64}, Vector{Float64}}, Vector{Float64}}}"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.BoundsConstraint-Tuple{Symbol, AbstractVector{Int64}, Union{Float64, Tuple{Vector{Float64}, Vector{Float64}}, Vector{Float64}}}"><code>DirectTrajOpt.Constraints.BoundsConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BoundsConstraint(
    name::Symbol,
    ts::Vector{Int},
    bounds::Union{Float64, Vector{Float64}, Tuple{Vector{Float64}, Vector{Float64}}};
    subcomponents=nothing,
    label=&quot;bounds constraint on trajectory variable $name&quot;
)</code></pre><p>Constructs box constraint for trajectory variable. Indices are computed when applied to a trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>name</code>: Variable name</li><li><code>ts</code>: Time indices</li><li><code>bounds</code>: Can be:<ul><li>Scalar: symmetric bounds [-bounds, bounds]</li><li>Vector: symmetric bounds [-bounds, bounds] element-wise</li><li>Tuple: (lower<em>bounds, upper</em>bounds)</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/bounds_constraint.jl#L31-L50">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.EqualityConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.EqualityConstraint"><code>DirectTrajOpt.Constraints.EqualityConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct EqualityConstraint &lt;: AbstractLinearConstraint</code></pre><p>Represents a linear equality constraint defined by variable names. Indices are computed when constraint is applied in constrain!.</p><p><strong>Fields</strong></p><ul><li><code>var_names::Union{Symbol, Vector{Symbol}}</code>: Variable name(s) to constrain</li><li><code>times::Union{Nothing, Vector{Int}}</code>: Time indices (nothing for global variables)</li><li><code>values::Vector{Float64}</code>: Constraint values</li><li><code>is_global::Bool</code>: Whether this is a global variable constraint</li><li><code>label::String</code>: Constraint label</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/equality_constraint.jl#L8-L20">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.EqualityConstraint-Tuple{Symbol, AbstractVector{Int64}, Union{Float64, Vector{Float64}}}"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.EqualityConstraint-Tuple{Symbol, AbstractVector{Int64}, Union{Float64, Vector{Float64}}}"><code>DirectTrajOpt.Constraints.EqualityConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EqualityConstraint(
    name::Symbol,
    ts::Vector{Int},
    val::Union{Float64, Vector{Float64}};
    label=&quot;equality constraint on trajectory variable $name&quot;
)</code></pre><p>Constructs equality constraint for trajectory variable. Indices are computed when applied to a trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/equality_constraint.jl#L29-L39">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.L1SlackConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.L1SlackConstraint"><code>DirectTrajOpt.Constraints.L1SlackConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct L1SlackConstraint &lt;: AbstractLinearConstraint</code></pre><p>Linear constraint tying a slack variable to the absolute value of another variable.</p><p>For each timestep <code>k</code> and component <code>i</code>, enforces:</p><p class="math-container">\[v_{k,i} \leq s_{k,i}, \quad -v_{k,i} \leq s_{k,i}
\quad \Longleftrightarrow \quad |v_{k,i}| \leq s_{k,i}\]</p><p>The bound <code>s ≥ 0</code> is expected to come from the trajectory&#39;s bounds on the slack component. When combined with a <a href="#DirectTrajOpt.Objectives.LinearRegularizer"><code>LinearRegularizer</code></a> on the slack variable, this yields an exact L1 penalty on <code>v</code>.</p><p><strong>Fields</strong></p><ul><li><code>var_name::Symbol</code>: Variable to penalize (e.g. <code>:du</code>)</li><li><code>slack_name::Symbol</code>: Slack variable name (e.g. <code>:s_du</code>)</li><li><code>times::Vector{Int}</code>: Time indices where constraint is applied</li><li><code>label::String</code>: Constraint label</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/l1_slack_constraint.jl#L7-L27">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.L1SlackConstraint-Tuple{Symbol, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.L1SlackConstraint-Tuple{Symbol, Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.Constraints.L1SlackConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">L1SlackConstraint(
    var_name::Symbol,
    slack_name::Symbol,
    traj::NamedTrajectory;
    times::AbstractVector{Int}=1:traj.N,
    label=&quot;L1 slack constraint: |var_name| ≤ slack_name&quot;
)</code></pre><p>Construct an L1 slack constraint tying <code>|var_name|</code> to <code>slack_name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/l1_slack_constraint.jl#L35-L45">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.NonlinearGlobalConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.NonlinearGlobalConstraint"><code>DirectTrajOpt.Constraints.NonlinearGlobalConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonlinearGlobalConstraint{F} &lt;: AbstractNonlinearConstraint</code></pre><p>Constraint applied to global (trajectory-wide) parameters only.</p><p>Computes Jacobians and Hessians on-the-fly using automatic differentiation. For pre-allocated optimization, see Piccolissimo.OptimizedNonlinearGlobalConstraint.</p><p><strong>Fields</strong></p><ul><li><code>g::F</code>: Constraint function mapping global variables -&gt; constraint values</li><li><code>global_names::Vector{Symbol}</code>: Names of global variables the constraint depends on</li><li><code>equality::Bool</code>: If true, g(globals) = 0; if false, g(globals) ≤ 0</li><li><code>dim::Int</code>: Dimension of constraint output</li><li><code>global_dim::Int</code>: Combined dimension of all constrained global variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/global_constraint.jl#L9-L23">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.NonlinearGlobalKnotPointConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.NonlinearGlobalKnotPointConstraint"><code>DirectTrajOpt.Constraints.NonlinearGlobalKnotPointConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonlinearGlobalKnotPointConstraint{F} &lt;: AbstractNonlinearConstraint</code></pre><p>Constraint applied at individual knot points that also depends on global parameters.</p><p>Computes Jacobians and Hessians on-the-fly using automatic differentiation. For pre-allocated optimization, see Piccolissimo.OptimizedNonlinearGlobalKnotPointConstraint.</p><p><strong>Fields</strong></p><ul><li><code>g::F</code>: Constraint function mapping (knot<em>point</em>vars..., global_vars..., params) -&gt; constraint values</li><li><code>var_names::Vector{Symbol}</code>: Names of knot point variables the constraint depends on</li><li><code>global_names::Vector{Symbol}</code>: Names of global variables the constraint depends on</li><li><code>times::Vector{Int}</code>: Time indices where constraint is applied</li><li><code>equality::Bool</code>: If true, g(x, globals) = 0; if false, g(x, globals) ≤ 0</li><li><code>params::Vector</code>: Parameters for each time index</li><li><code>g_dim::Int</code>: Dimension of constraint output at each time step</li><li><code>var_dim::Int</code>: Combined dimension of knot point variables</li><li><code>global_dim::Int</code>: Combined dimension of global variables</li><li><code>combined_dim::Int</code>: var<em>dim + global</em>dim</li><li><code>dim::Int</code>: Total constraint dimension (g_dim * length(times))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/global_knot_point_constraint.jl#L9-L29">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.NonlinearKnotPointConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.NonlinearKnotPointConstraint"><code>DirectTrajOpt.Constraints.NonlinearKnotPointConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonlinearKnotPointConstraint{F} &lt;: AbstractNonlinearConstraint</code></pre><p>Constraint applied at individual knot points over a trajectory.</p><p>Computes Jacobians and Hessians on-the-fly using automatic differentiation. For pre-allocated optimization, see Piccolissimo.OptimizedNonlinearKnotPointConstraint.</p><p><strong>Fields</strong></p><ul><li><code>g::F</code>: Constraint function mapping (variables..., params) -&gt; constraint values</li><li><code>var_names::Vector{Symbol}</code>: Names of trajectory variables the constraint depends on</li><li><code>equality::Bool</code>: If true, g(x) = 0; if false, g(x) ≤ 0</li><li><code>times::Vector{Int}</code>: Time indices where constraint is applied</li><li><code>params::Vector</code>: Parameters for each time index (e.g., time-varying targets)</li><li><code>g_dim::Int</code>: Dimension of constraint output at each time step</li><li><code>var_dim::Int</code>: Combined dimension of all constrained variables</li><li><code>dim::Int</code>: Total constraint dimension (g_dim * length(times))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/knot_point_constraint.jl#L9-L26">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.NonlinearKnotPointConstraint-Tuple{AbstractVector, NamedTrajectories.StructKnotPoint.KnotPoint, Int64}"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.NonlinearKnotPointConstraint-Tuple{AbstractVector, NamedTrajectories.StructKnotPoint.KnotPoint, Int64}"><code>DirectTrajOpt.Constraints.NonlinearKnotPointConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(constraint::NonlinearKnotPointConstraint)(δ, zₖ::KnotPoint, k::Int)</code></pre><p>Evaluate the constraint at a single knot point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/knot_point_constraint.jl#L206-L210">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.SymmetryConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.SymmetryConstraint"><code>DirectTrajOpt.Constraints.SymmetryConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SymmetryConstraint &lt;: AbstractLinearConstraint</code></pre><p>Constraint enforcing symmetry in trajectory variables across time. Even symmetry: x[t] = x[N-t+1] Odd symmetry: x[t] = -x[N-t+1]</p><p><strong>Fields</strong></p><ul><li><code>var_name::Symbol</code>: Variable name to constrain</li><li><code>component_indices::Vector{Int}</code>: Which components of the variable</li><li><code>even::Bool</code>: True for even symmetry (x[t] = x[N-t+1]), false for odd (-x[t] = x[N-t+1])</li><li><code>include_timestep::Bool</code>: Whether to also enforce even symmetry on timesteps</li><li><code>label::String</code>: Constraint label</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/symmetry_constraint.jl#L4-L17">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.TimeConsistencyConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.TimeConsistencyConstraint"><code>DirectTrajOpt.Constraints.TimeConsistencyConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TimeConsistencyConstraint &lt;: AbstractLinearConstraint</code></pre><p>Constraint that enforces consistency between time values and timesteps:     t<em>{k+1} = t</em>k + Δt_k  for k = 1, ..., T-1</p><p>This is used when both absolute times (<code>:t</code>) and timesteps (<code>:Δt</code>) are stored in the trajectory and need to remain consistent during optimization.</p><p><strong>Fields</strong></p><ul><li><code>time_name::Symbol</code>: Name of the time variable (default <code>:t</code>)</li><li><code>timestep_name::Symbol</code>: Name of the timestep variable (default <code>:Δt</code>)</li><li><code>label::String</code>: Constraint label</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/time_consistency_constraint.jl#L3-L16">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.TimeConsistencyConstraint-Tuple{}"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.TimeConsistencyConstraint-Tuple{}"><code>DirectTrajOpt.Constraints.TimeConsistencyConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TimeConsistencyConstraint(;
    time_name::Symbol=:t,
    timestep_name::Symbol=:Δt,
    label=&quot;time consistency constraint (t_{k+1} = t_k + Δt_k)&quot;
)</code></pre><p>Construct a constraint enforcing t<em>{k+1} = t</em>k + Δt_k for all k.</p><p><strong>Arguments</strong></p><ul><li><code>time_name</code>: Name of the time variable in the trajectory (default <code>:t</code>)</li><li><code>timestep_name</code>: Name of the timestep variable in the trajectory (default <code>:Δt</code>)</li><li><code>label</code>: Constraint label for logging/debugging</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/time_consistency_constraint.jl#L23-L36">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.TotalConstraint"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.TotalConstraint"><code>DirectTrajOpt.Constraints.TotalConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TotalConstraint &lt;: AbstractLinearConstraint</code></pre><p>Constraint that the sum of a variable&#39;s components equals a target value. Commonly used for trajectory duration constraints.</p><p><strong>Fields</strong></p><ul><li><code>var_name::Symbol</code>: Variable name to sum</li><li><code>component_index::Int</code>: Which component of the variable (1 for scalar variables)</li><li><code>value::Float64</code>: Target sum value</li><li><code>label::String</code>: Constraint label</li></ul><p><strong>Note</strong></p><p>When applied to the trajectory&#39;s timestep variable, only the first N-1 timesteps are summed (the last knot point has no duration after it). For other variables, all N values are summed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/total_constraint.jl#L4-L19">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.eval_hessian_of_lagrangian-Tuple{NonlinearGlobalConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, AbstractVector}"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.eval_hessian_of_lagrangian-Tuple{NonlinearGlobalConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, AbstractVector}"><code>DirectTrajOpt.CommonInterface.eval_hessian_of_lagrangian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eval_hessian_of_lagrangian(constraint::NonlinearGlobalConstraint, traj::NamedTrajectory, μ::AbstractVector)</code></pre><p>Compute and return the full Hessian of the Lagrangian using automatic differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/global_constraint.jl#L136-L140">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.eval_hessian_of_lagrangian-Tuple{NonlinearGlobalKnotPointConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, AbstractVector}"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.eval_hessian_of_lagrangian-Tuple{NonlinearGlobalKnotPointConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, AbstractVector}"><code>DirectTrajOpt.CommonInterface.eval_hessian_of_lagrangian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eval_hessian_of_lagrangian(constraint::NonlinearGlobalKnotPointConstraint, traj::NamedTrajectory, μ::AbstractVector)</code></pre><p>Compute and return the full Hessian of the Lagrangian using automatic differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/global_knot_point_constraint.jl#L207-L211">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.eval_hessian_of_lagrangian-Tuple{NonlinearKnotPointConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, AbstractVector}"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.eval_hessian_of_lagrangian-Tuple{NonlinearKnotPointConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, AbstractVector}"><code>DirectTrajOpt.CommonInterface.eval_hessian_of_lagrangian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eval_hessian_of_lagrangian(constraint::NonlinearKnotPointConstraint, traj::NamedTrajectory, μ::AbstractVector)</code></pre><p>Compute and return the full Hessian of the Lagrangian using automatic differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/knot_point_constraint.jl#L270-L274">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.eval_jacobian-Tuple{NonlinearGlobalConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.eval_jacobian-Tuple{NonlinearGlobalConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.CommonInterface.eval_jacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eval_jacobian(constraint::NonlinearGlobalConstraint, traj::NamedTrajectory)</code></pre><p>Compute and return the full Jacobian using automatic differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/global_constraint.jl#L113-L117">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.eval_jacobian-Tuple{NonlinearGlobalKnotPointConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.eval_jacobian-Tuple{NonlinearGlobalKnotPointConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.CommonInterface.eval_jacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eval_jacobian(constraint::NonlinearGlobalKnotPointConstraint, traj::NamedTrajectory)</code></pre><p>Compute and return the full Jacobian using automatic differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/global_knot_point_constraint.jl#L166-L170">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.eval_jacobian-Tuple{NonlinearKnotPointConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.eval_jacobian-Tuple{NonlinearKnotPointConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.CommonInterface.eval_jacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eval_jacobian(constraint::NonlinearKnotPointConstraint, traj::NamedTrajectory)</code></pre><p>Compute and return the full Jacobian using automatic differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/knot_point_constraint.jl#L249-L253">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.evaluate!-Tuple{AbstractVector, NonlinearGlobalConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.evaluate!-Tuple{AbstractVector, NonlinearGlobalConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.CommonInterface.evaluate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate!(values::AbstractVector, constraint::NonlinearGlobalConstraint, traj::NamedTrajectory)</code></pre><p>Evaluate the global constraint, storing results in-place in <code>values</code>. This is part of the common interface with integrators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/global_constraint.jl#L96-L101">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.evaluate!-Tuple{AbstractVector, NonlinearGlobalKnotPointConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.evaluate!-Tuple{AbstractVector, NonlinearGlobalKnotPointConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.CommonInterface.evaluate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate!(values::AbstractVector, constraint::NonlinearGlobalKnotPointConstraint, traj::NamedTrajectory)</code></pre><p>Evaluate the global knot point constraint, storing results in-place in <code>values</code>. This is part of the common interface with integrators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/global_knot_point_constraint.jl#L142-L147">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.CommonInterface.evaluate!-Tuple{AbstractVector, NonlinearKnotPointConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.CommonInterface.evaluate!-Tuple{AbstractVector, NonlinearKnotPointConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.CommonInterface.evaluate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate!(values::AbstractVector, constraint::NonlinearKnotPointConstraint, traj::NamedTrajectory)</code></pre><p>Evaluate the constraint at all specified time indices, storing results in-place in <code>values</code>. This is part of the common interface with integrators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/nonlinear/knot_point_constraint.jl#L229-L234">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.DurationConstraint-Tuple{Float64}"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.DurationConstraint-Tuple{Float64}"><code>DirectTrajOpt.Constraints.DurationConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DurationConstraint(value::Float64; label=&quot;duration constraint of $value&quot;)</code></pre><p>Constraint that the total trajectory duration equals a target value. The trajectory&#39;s timestep variable is inferred when applied.</p><p><strong>Note</strong></p><p>Duration is computed as the sum of the first N-1 timesteps, since the final knot point represents the end state and has no duration after it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/total_constraint.jl#L27-L36">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.GlobalBoundsConstraint-Tuple{Symbol, Union{Float64, Tuple{Vector{Float64}, Vector{Float64}}, Vector{Float64}}}"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.GlobalBoundsConstraint-Tuple{Symbol, Union{Float64, Tuple{Vector{Float64}, Vector{Float64}}, Vector{Float64}}}"><code>DirectTrajOpt.Constraints.GlobalBoundsConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">GlobalBoundsConstraint(
    name::Symbol,
    bounds::Union{Float64, Vector{Float64}, Tuple{Vector{Float64}, Vector{Float64}}};
    label=&quot;bounds constraint on global variable $name&quot;
)</code></pre><p>Constructs box constraint for global variable. Indices are computed when applied to a trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/bounds_constraint.jl#L68-L77">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.GlobalEqualityConstraint-Tuple{Symbol, Union{Float64, Vector{Float64}}}"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.GlobalEqualityConstraint-Tuple{Symbol, Union{Float64, Vector{Float64}}}"><code>DirectTrajOpt.Constraints.GlobalEqualityConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">GlobalEqualityConstraint(
    name::Symbol,
    val::Union{Float64, Vector{Float64}};
    label=&quot;equality constraint on global variable $name&quot;
)::EqualityConstraint</code></pre><p>Constructs equality constraint for global variable. Indices are computed when applied to a trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/equality_constraint.jl#L58-L67">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.SymmetricControlConstraint-Tuple{Symbol, Vector{Int64}}"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.SymmetricControlConstraint-Tuple{Symbol, Vector{Int64}}"><code>DirectTrajOpt.Constraints.SymmetricControlConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SymmetricControlConstraint(
    name::Symbol,
    idx::Vector{Int};
    even=true,
    include_timestep=true,
    label=&quot;symmetry constraint on $name&quot;
)</code></pre><p>Constraint enforcing symmetry on control variables. Indices are computed when applied to a trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/symmetry_constraint.jl#L26-L37">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.TimeStepsAllEqualConstraint-Tuple{}"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.TimeStepsAllEqualConstraint-Tuple{}"><code>DirectTrajOpt.Constraints.TimeStepsAllEqualConstraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TimeStepsAllEqualConstraint(;label=&quot;timesteps all equal constraint&quot;)</code></pre><p>Constraint that all timesteps are equal (for fixed-timestep trajectories). The trajectory&#39;s timestep variable is inferred when applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/linear/all_equal_constraint.jl#L21-L26">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.get_full_hessian"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.get_full_hessian"><code>DirectTrajOpt.Constraints.get_full_hessian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_full_hessian(constraint, traj::NamedTrajectory)</code></pre><p>Assemble the full sparse Hessian matrix from compact per-timestep blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/_constraints.jl#L105-L109">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.get_full_jacobian"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.get_full_jacobian"><code>DirectTrajOpt.Constraints.get_full_jacobian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_full_jacobian(constraint, traj::NamedTrajectory)</code></pre><p>Assemble the full sparse Jacobian matrix from compact per-timestep blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/_constraints.jl#L98-L102">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.hessian_of_lagrangian!"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.hessian_of_lagrangian!"><code>DirectTrajOpt.Constraints.hessian_of_lagrangian!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hessian_of_lagrangian!(constraint, traj::NamedTrajectory, μ::AbstractVector)</code></pre><p>Compute the Hessian of the Lagrangian (μ&#39;g) for the constraint in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/_constraints.jl#L91-L95">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Constraints.test_constraint-Tuple{AbstractNonlinearConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.Constraints.test_constraint-Tuple{AbstractNonlinearConstraint, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.Constraints.test_constraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">test_constraint(
    constraint::AbstractNonlinearConstraint,
    traj::NamedTrajectory;
    show_jacobian_diff=false,
    show_hessian_diff=false,
    test_equality=true,
    atol=1e-5,
    rtol=1e-5
)</code></pre><p>Test that constraint Jacobian and Hessian match finite difference approximations.</p><p><strong>Arguments</strong></p><ul><li><code>constraint</code>: Constraint to test</li><li><code>traj</code>: Trajectory to evaluate constraint on</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>show_jacobian_diff=false</code>: Print detailed Jacobian differences</li><li><code>show_hessian_diff=false</code>: Print detailed Hessian differences</li><li><code>test_equality=true</code>: Test element-wise equality (vs norm-based test)</li><li><code>atol=1e-5</code>: Absolute tolerance</li><li><code>rtol=1e-5</code>: Relative tolerance</li></ul><p><strong>Returns</strong></p><p>Tuple of (∂g, ∂g<em>finite</em>diff, μ∂²g, μ∂²g<em>finite</em>diff) for inspection</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">g(x) = [norm(x) - 1.0]
constraint = NonlinearKnotPointConstraint(g, :x, traj)
test_constraint(constraint, traj)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/constraints/_constraints.jl#L116-L149">source</a></section></details></article><h2 id="Integrators"><a class="docs-heading-anchor" href="#Integrators">Integrators</a><a id="Integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators" title="Permalink"></a></h2><article><details class="docstring"><summary id="DirectTrajOpt.Integrators.AbstractIntegrator"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.AbstractIntegrator"><code>DirectTrajOpt.Integrators.AbstractIntegrator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractIntegrator</code></pre><p>Abstract supertype for all dynamics integrators.</p><p>Subtypes must implement the <a href="#DirectTrajOpt.CommonInterface"><code>CommonInterface</code></a> methods:</p><ul><li><code>evaluate!(δ, integrator, traj)</code> — compute dynamics residuals</li><li><code>eval_jacobian(integrator, traj)</code> — compute sparse Jacobian</li><li><code>eval_hessian_of_lagrangian(integrator, traj, μ)</code> — compute sparse Hessian of Lagrangian</li></ul><p>and must have fields <code>x_dim::Int</code> and <code>dim::Int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/integrators/_integrators.jl#L22-L33">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Integrators.BilinearIntegrator"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.BilinearIntegrator"><code>DirectTrajOpt.Integrators.BilinearIntegrator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BilinearIntegrator &lt;: AbstractBilinearIntegrator</code></pre><p>Integrator for control-linear dynamics of the form ẋ = G(u)x.</p><p>This integrator uses matrix exponential methods to compute accurate state transitions for bilinear systems where the system matrix depends linearly on the control input.</p><p><strong>Fields</strong></p><ul><li><code>G::Function</code>: Function mapping control u to system matrix G(u)</li><li><code>x_name::Symbol</code>: State variable name</li><li><code>u_name::Symbol</code>: Control variable name</li><li><code>x_dim::Int</code>: Dimension of state variable</li><li><code>var_dim::Int</code>: Combined dimension of all variables this integrator depends on (2*x<em>dim + u</em>dim + 1)</li><li><code>dim::Int</code>: Total constraint dimension (x_dim * (N-1))</li><li><code>∂fs::Vector{SparseMatrixCSC{Float64, Int}}</code>: Pre-allocated compact Jacobian storage (x<em>dim × var</em>dim per timestep)</li><li><code>μ∂²fs::Vector{SparseMatrixCSC{Float64, Int}}</code>: Pre-allocated compact Hessian storage (var<em>dim × var</em>dim per timestep)</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">BilinearIntegrator(G::Function, x::Symbol, u::Symbol, traj::NamedTrajectory)</code></pre><p><strong>Arguments</strong></p><ul><li><code>G</code>: Function taking control u and returning state matrix (x<em>dim × x</em>dim)</li><li><code>x</code>: State variable name</li><li><code>u</code>: Control variable name</li><li><code>traj</code>: Trajectory structure used to determine dimensions and pre-allocate storage</li></ul><p><strong>Dynamics</strong></p><p>Computes the constraint: x<em>{k+1} - exp(Δt * G(u</em>k)) * x_k = 0 Dependencies: xₖ, uₖ, Δtₖ, xₖ₊₁</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Linear dynamics: ẋ = (A + Σᵢ uᵢ Bᵢ) x
A = [-0.1 1.0; -1.0 -0.1]
B = [0.0 0.0; 0.0 1.0]
G = u -&gt; A + u[1] * B

integrator = BilinearIntegrator(G, :x, :u, traj)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/integrators/bilinear_integrator.jl#L18-L60">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Integrators.DerivativeIntegrator"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.DerivativeIntegrator"><code>DirectTrajOpt.Integrators.DerivativeIntegrator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DerivativeIntegrator &lt;: AbstractIntegrator</code></pre><p>Integrator for derivative constraints of the form xₖ₊₁ - xₖ - Δt * ẋₖ = 0.</p><p>This enforces smoothness by relating a variable to its derivative.</p><p><strong>Fields</strong></p><ul><li><code>f::Function</code>: Constraint function f(xₖ₊₁, xₖ, ẋₖ, Δtₖ) = xₖ₊₁ - xₖ - Δtₖ * ẋₖ</li><li><code>x_name::Symbol</code>: Variable name</li><li><code>ẋ_name::Symbol</code>: Derivative variable name</li><li><code>x_dim::Int</code>: Dimension of variable</li><li><code>var_dim::Int</code>: Combined dimension (2*x_dim + 1 for xₖ, ẋₖ, Δtₖ, xₖ₊₁)</li><li><code>dim::Int</code>: Total constraint dimension (x_dim * (N-1))</li><li><code>∂fs::Vector{SparseMatrixCSC{Float64, Int}}</code>: Compact Jacobian storage</li><li><code>μ∂²fs::Vector{SparseMatrixCSC{Float64, Int}}</code>: Compact Hessian storage</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Enforce velocity smoothness: vₖ₊₁ - vₖ - Δt * aₖ = 0
integrator = DerivativeIntegrator(:v, :a, traj)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/integrators/derivative_integrator.jl#L3-L25">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Integrators.TimeDependentBilinearIntegrator"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.TimeDependentBilinearIntegrator"><code>DirectTrajOpt.Integrators.TimeDependentBilinearIntegrator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TimeDependentBilinearIntegrator{F} &lt;: AbstractBilinearIntegrator</code></pre><p>Integrator for time-dependent bilinear dynamics of the form:</p><p class="math-container">\[\dot{x} = G(u(t), t) \, x\]</p><p>where <code>G</code> is a matrix-valued function of both the control <code>u</code> and time <code>t</code>. The control is interpolated between knot points using a spline of the specified order (0 = zero-order hold, 1 = linear interpolation). Integration over each time step is performed with an ODE solver (Tsit5) on the normalized interval <code>[0, 1]</code>.</p><p><strong>Fields</strong></p><ul><li><code>f::Function</code>: Compiled residual function <code>(x_{k+1}, x_k, p_k, t_k, Δt_k) -&gt; residual</code></li><li><code>x_name::Symbol</code>: Name of the state variable in the trajectory</li><li><code>u_name::Symbol</code>: Name of the control variable in the trajectory</li><li><code>t_name::Symbol</code>: Name of the time variable in the trajectory</li><li><code>spline_order::Int</code>: Control interpolation order (0 or 1)</li><li><code>x_dim::Int</code>: Dimension of the state vector</li><li><code>u_dim::Int</code>: Dimension of the control vector</li><li><code>dim::Int</code>: Total constraint dimension <code>x_dim * (N - 1)</code></li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">TimeDependentBilinearIntegrator(
    G::Function, x::Symbol, u::Symbol, t::Symbol,
    traj::NamedTrajectory;
    spline_order::Int=1, solve_kwargs=(;)
)</code></pre><p><strong>Arguments</strong></p><ul><li><code>G</code>: Function <code>(u, t) -&gt; Matrix</code> returning the generator at control value <code>u</code> and time <code>t</code></li><li><code>x</code>: State variable name</li><li><code>u</code>: Control variable name</li><li><code>t</code>: Time variable name</li><li><code>traj</code>: Trajectory providing dimensions and structure</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>spline_order=1</code>: Order of control interpolation (0 for piecewise constant, 1 for linear)</li><li><code>solve_kwargs=(;)</code>: Additional keyword arguments passed to <code>OrdinaryDiffEq.solve</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">G(u, t) = [-0.1 1.0; -1.0 -0.1] + u[1] * [0.0 cos(t); cos(t) 0.0]
integrator = TimeDependentBilinearIntegrator(G, :x, :u, :t, traj)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/integrators/time_dependent_bilinear_integrator.jl#L10-L59">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Integrators.dense-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.dense-Tuple{Any, Any, Any}"><code>DirectTrajOpt.Integrators.dense</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dense(vals, structure, shape)</code></pre><p>Convert sparse data to dense matrix.</p><p><strong>Arguments</strong></p><ul><li><code>vals</code>: vector of values</li><li><code>structure</code>: vector of tuples of indices</li><li><code>shape</code>: tuple of matrix dimensions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/test/test_utils.jl#L7-L16">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Integrators.get_hessian_of_lagrangian_structure-Tuple{AbstractIntegrator, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.get_hessian_of_lagrangian_structure-Tuple{AbstractIntegrator, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.Integrators.get_hessian_of_lagrangian_structure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_hessian_of_lagrangian_structure(integrator::AbstractIntegrator, traj::NamedTrajectory)</code></pre><p>Return the sparsity pattern of the integrator&#39;s Hessian of the Lagrangian as a sparse matrix with ones at every potentially nonzero entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/integrators/_integrators.jl#L62-L67">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Integrators.get_jacobian_structure-Tuple{AbstractIntegrator, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.get_jacobian_structure-Tuple{AbstractIntegrator, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.Integrators.get_jacobian_structure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_jacobian_structure(integrator::AbstractIntegrator, traj::NamedTrajectory)</code></pre><p>Return the sparsity pattern of the integrator&#39;s Jacobian as a sparse matrix with ones at every potentially nonzero entry. Used by the solver to pre-allocate structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/integrators/_integrators.jl#L43-L48">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Integrators.show_diffs-Tuple{AbstractMatrix, AbstractMatrix}"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.show_diffs-Tuple{AbstractMatrix, AbstractMatrix}"><code>DirectTrajOpt.Integrators.show_diffs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">show_diffs(A::Matrix, B::Matrix)</code></pre><p>Show differences between matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/test/test_utils.jl#L32-L36">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Integrators.test_integrator-Tuple{AbstractIntegrator, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.Integrators.test_integrator-Tuple{AbstractIntegrator, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.Integrators.test_integrator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">test_integrator(
    integrator::AbstractIntegrator,
    traj::NamedTrajectory;
    show_jacobian_diff=false,
    show_hessian_diff=false,
    test_equality=true,
    gauss_newton=false,
    atol=1e-5,
    rtol=1e-5
)</code></pre><p>Validate an integrator&#39;s analytic Jacobian and Hessian against finite difference approximations. Intended for use in <code>@testitem</code> blocks.</p><p><strong>Returns</strong></p><p>Tuple of <code>(∂f, ∂f_finite_diff, μ∂²f, μ∂²f_finite_diff)</code> for manual inspection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/integrators/_integrators.jl#L79-L96">source</a></section></details></article><h2 id="Objectives"><a class="docs-heading-anchor" href="#Objectives">Objectives</a><a id="Objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Objectives" title="Permalink"></a></h2><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.AbstractObjective"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.AbstractObjective"><code>DirectTrajOpt.Objectives.AbstractObjective</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractObjective</code></pre><p>Abstract type for all objective functions in trajectory optimization.</p><p>Concrete objective types must implement:</p><ul><li><code>objective_value(obj, traj)</code>: Evaluate the objective at trajectory</li><li><code>gradient!(∇, obj, traj)</code>: Compute gradient in-place (gradient is always dense)</li><li><code>hessian_structure(obj, traj)</code>: Return sparsity structure as sparse matrix</li><li><code>get_full_hessian(obj, traj)</code>: Return the full Hessian matrix</li></ul><p>Objectives support addition and scalar multiplication through <code>CompositeObjective</code>.</p><p>Note: Unlike constraints and integrators, objective gradients are always dense, so no gradient_structure method is needed. The gradient! method fills the entire ∇ vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/_objectives.jl#L33-L48">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.CompositeObjective"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.CompositeObjective"><code>DirectTrajOpt.Objectives.CompositeObjective</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompositeObjective &lt;: AbstractObjective</code></pre><p>Represents a weighted sum or composition of multiple objectives.</p><p><strong>Fields</strong></p><ul><li><code>objectives::Vector{AbstractObjective}</code>: Individual objectives to combine</li><li><code>weights::Vector{Float64}</code>: Weight for each objective</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/_objectives.jl#L93-L101">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.GlobalKnotPointObjective"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.GlobalKnotPointObjective"><code>DirectTrajOpt.Objectives.GlobalKnotPointObjective</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GlobalKnotPointObjective &lt;: AbstractObjective</code></pre><p>Knot point objective that includes both time-varying and global trajectory components.</p><p>Objective function ℓ operates on extracted variable values:</p><p class="math-container">\[J = \sum_{k \in \text{times}} Q_k \ell([x_k; g], p_k)\]</p><p>where ℓ receives both knot point variables and global variables concatenated.</p><p><strong>Fields</strong></p><ul><li><code>ℓ::Function</code>: Objective function mapping (knot<em>vars + global</em>vars, params) → scalar cost</li><li><code>var_names::Vector{Symbol}</code>: Names of trajectory variables at knot points</li><li><code>global_names::Vector{Symbol}</code>: Names of global trajectory variables</li><li><code>times::Vector{Int}</code>: Time indices where objective is evaluated</li><li><code>params::Vector</code>: Parameters for each time index</li><li><code>Qs::Vector{Float64}</code>: Weights for each time index</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/global_objectives.jl#L131-L150">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.GlobalObjective"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.GlobalObjective"><code>DirectTrajOpt.Objectives.GlobalObjective</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GlobalObjective &lt;: AbstractObjective</code></pre><p>Objective that only involves global (non-time-varying) trajectory components.</p><p>Objective function ℓ operates on extracted global variable values:</p><p class="math-container">\[J = Q \cdot \ell(\text{global\_vars})\]</p><p><strong>Fields</strong></p><ul><li><code>ℓ::Function</code>: Objective function mapping global variables → scalar cost</li><li><code>global_names::Vector{Symbol}</code>: Names of global trajectory variables</li><li><code>Q::Float64</code>: Weight for the objective</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">GlobalObjective(
    ℓ::Function,
    global_names::Union{Symbol, AbstractVector{Symbol}},
    traj::NamedTrajectory;
    Q::Float64=1.0
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/global_objectives.jl#L10-L34">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.KnotPointObjective"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.KnotPointObjective"><code>DirectTrajOpt.Objectives.KnotPointObjective</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KnotPointObjective &lt;: AbstractObjective</code></pre><p>Knot point summed objective function for trajectory optimization.</p><p>Stores the objective function ℓ that operates on extracted variable values:</p><p class="math-container">\[J = \sum_{k \in \text{times}} Q_k \ell(x_k, p_k)\]</p><p>where ℓ is evaluated on trajectory variables at each knot point.</p><p><strong>Fields</strong></p><ul><li><code>ℓ::Function</code>: Objective function mapping (variables..., params) -&gt; scalar cost</li><li><code>var_names::Vector{Symbol}</code>: Names of trajectory variables the objective depends on</li><li><code>times::Vector{Int}</code>: Time indices where objective is evaluated</li><li><code>params::Vector</code>: Parameters for each time index</li><li><code>Qs::Vector{Float64}</code>: Weights for each time index</li><li><code>∂²Ls::Vector{SparseMatrixCSC{Float64, Int}}</code>: Preallocated sparse Hessian storage (one per timestep)</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">KnotPointObjective(
    ℓ::Function,
    names::Union{Symbol, AbstractVector{Symbol}},
    traj::NamedTrajectory,
    params::AbstractVector;
    times::AbstractVector{Int}=1:traj.N,
    Qs::AbstractVector{Float64}=ones(length(times))
)</code></pre><p>For single variable: <code>ℓ(x, p)</code> where <code>x</code> is the variable values at a knot point For multiple variables: <code>ℓ(x, u, p)</code> where each argument corresponds to a variable in <code>names</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Single variable
obj = KnotPointObjective((x, _) -&gt; norm(x)^2, :x, traj, fill(nothing, traj.N))

# Multiple variables - concatenated
obj = KnotPointObjective((xu, _) -&gt; xu[1]^2 + xu[2]^2, [:x, :u], traj, fill(nothing, traj.N))

# With parameters and weights
obj = KnotPointObjective(
    (x, p) -&gt; norm(x - p)^2, :x, traj, [x_targets...];
    times=1:10, Qs=[1.0, 2.0, ...]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/knot_point_objectives.jl#L10-L59">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.LinearRegularizer"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.LinearRegularizer"><code>DirectTrajOpt.Objectives.LinearRegularizer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearRegularizer &lt;: AbstractObjective</code></pre><p>Linear regularization objective for a trajectory component.</p><p>Computes:</p><p class="math-container">\[J = \sum_{k \in \text{times}} \sum_i R_i \cdot v_{k,i} \cdot \Delta t_k\]</p><p>Used for L1 penalty via slack variables: when applied to a non-negative slack variable <code>s ≥ 0</code> satisfying <code>|du| ≤ s</code>, minimizing <code>Σ R_i s_i Δt</code> yields the exact L1 norm of <code>du</code>.</p><p>Gradients and Hessians are computed analytically. The Hessian has only cross-terms ∂²J/∂v∂Δt = R_i (no diagonal).</p><p><strong>Fields</strong></p><ul><li><code>name::Symbol</code>: Name of the variable to regularize</li><li><code>R::Vector{Float64}</code>: Per-component weights</li><li><code>times::Vector{Int}</code>: Time indices where regularization is applied</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">LinearRegularizer(
    name::Symbol,
    traj::NamedTrajectory,
    R::Union{Real, AbstractVector{&lt;:Real}};
    times::AbstractVector{Int}=1:traj.N
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/regularizers.jl#L175-L206">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.MinimumTimeObjective"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.MinimumTimeObjective"><code>DirectTrajOpt.Objectives.MinimumTimeObjective</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MinimumTimeObjective &lt;: AbstractObjective</code></pre><p>Objective that minimizes total trajectory duration.</p><p>Computes:</p><p class="math-container">\[J = D \sum_{k=1}^{N-1} \Delta t_k\]</p><p><strong>Fields</strong></p><ul><li><code>D::Float64</code>: Scaling factor for minimum time objective</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">MinimumTimeObjective(traj::NamedTrajectory; D::Float64=1.0)
MinimumTimeObjective(traj::NamedTrajectory, D::Real)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/minimum_time_objective.jl#L5-L23">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.NullObjective"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.NullObjective"><code>DirectTrajOpt.Objectives.NullObjective</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NullObjective &lt;: AbstractObjective</code></pre><p>A zero objective that contributes nothing to the cost. Useful as a placeholder or when only constraints matter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/_objectives.jl#L199-L204">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.QuadraticRegularizer"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.QuadraticRegularizer"><code>DirectTrajOpt.Objectives.QuadraticRegularizer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">QuadraticRegularizer &lt;: AbstractObjective</code></pre><p>Quadratic regularization objective for a trajectory component.</p><p>Computes:</p><p class="math-container">\[J = \sum_{k \in \text{times}} \frac{1}{2} (v_k - v_\text{baseline})^T R (v_k - v_\text{baseline}) \Delta t\]</p><p>Gradients and Hessians are computed analytically.</p><p><strong>Fields</strong></p><ul><li><code>name::Symbol</code>: Name of the variable to regularize</li><li><code>R::Vector{Float64}</code>: Diagonal weight matrix</li><li><code>baseline::Matrix{Float64}</code>: Baseline values (column per timestep)</li><li><code>times::Vector{Int}</code>: Time indices where regularization is applied</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">QuadraticRegularizer(
    name::Symbol,
    traj::NamedTrajectory,
    R::Union{Real, AbstractVector{&lt;:Real}};
    baseline::AbstractMatrix{&lt;:Real}=zeros(traj.dims[name], traj.N),
    times::AbstractVector{Int}=1:traj.N
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/regularizers.jl#L9-L37">source</a></section></details></article><article><details class="docstring"><summary id="Base.:*-Tuple{Real, AbstractObjective}"><a class="docstring-binding" href="#Base.:*-Tuple{Real, AbstractObjective}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Scale an objective by a constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/_objectives.jl#L172-L174">source</a></section></details></article><article><details class="docstring"><summary id="Base.:+-Tuple{AbstractObjective, AbstractObjective}"><a class="docstring-binding" href="#Base.:+-Tuple{AbstractObjective, AbstractObjective}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Add two objectives together. Flattens nested CompositeObjectives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/_objectives.jl#L158-L160">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.TerminalObjective-Tuple{Function, AbstractVector{Symbol}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.TerminalObjective-Tuple{Function, AbstractVector{Symbol}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.Objectives.TerminalObjective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TerminalObjective(ℓ, names::Vector{Symbol}, traj; Q=1.0)</code></pre><p>Create a terminal objective that operates on multiple variables concatenated together.</p><p>This is useful for objectives that need to access multiple state variables at the final timestep, such as coherent fidelity objectives.</p><p><strong>Arguments</strong></p><ul><li><code>ℓ::Function</code>: Loss function taking concatenated values from all named variables</li><li><code>names::Vector{Symbol}</code>: Names of variables to concatenate</li><li><code>traj::NamedTrajectory</code>: The trajectory</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Q::Float64=1.0</code>: Weight on the objective</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/knot_point_objectives.jl#L125-L140">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.TerminalObjective-Tuple{Function, Symbol, Union{Symbol, AbstractVector{Symbol}}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.TerminalObjective-Tuple{Function, Symbol, Union{Symbol, AbstractVector{Symbol}}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.Objectives.TerminalObjective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TerminalObjective(
    ℓ::Function,
    name::Symbol,
    global_names::Union{Symbol, AbstractVector{Symbol}},
    traj::NamedTrajectory;
    Q::Float64=1.0
)</code></pre><p>Create a terminal (final time) objective that includes both knot point and global variables. This is a convenience wrapper around GlobalKnotPointObjective with times=[traj.N] and Qs=[Q].</p><p><strong>Arguments</strong></p><ul><li><code>ℓ::Function</code>: Objective function mapping concatenated [knot<em>vars; global</em>vars] → scalar</li><li><code>name::Symbol</code>: Name of the knot point variable</li><li><code>global_names</code>: Name(s) of global variable(s)</li><li><code>traj::NamedTrajectory</code>: The trajectory</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Terminal objective with knot point state and global parameter
TerminalObjective(
    xg -&gt; norm(xg[1:2] - xg[3:4])^2,  # Distance from state to goal
    :x, :x_goal, traj; Q=100.0
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/global_objectives.jl#L347-L373">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.get_full_hessian"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.get_full_hessian"><code>DirectTrajOpt.Objectives.get_full_hessian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_full_hessian(obj::AbstractObjective, traj::NamedTrajectory)</code></pre><p>Compute and return the full Hessian matrix of the objective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/_objectives.jl#L79-L83">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.gradient!"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.gradient!"><code>DirectTrajOpt.Objectives.gradient!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gradient!(∇::AbstractVector, obj::AbstractObjective, traj::NamedTrajectory)</code></pre><p>Compute the gradient of the objective in-place. The gradient is always dense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/_objectives.jl#L64-L68">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.hessian_structure"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.hessian_structure"><code>DirectTrajOpt.Objectives.hessian_structure</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hessian_structure(obj::AbstractObjective, traj::NamedTrajectory)</code></pre><p>Return the sparsity structure of the Hessian as a sparse matrix with non-zero entries where the Hessian has non-zero values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/_objectives.jl#L71-L76">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.objective_value"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.objective_value"><code>DirectTrajOpt.Objectives.objective_value</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">objective_value(obj::AbstractObjective, traj::NamedTrajectory)</code></pre><p>Evaluate the objective function at the given trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/_objectives.jl#L55-L59">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Objectives.test_objective-Tuple{AbstractObjective, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.Objectives.test_objective-Tuple{AbstractObjective, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.Objectives.test_objective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">test_objective(
    obj::AbstractObjective,
    traj::NamedTrajectory;
    show_gradient_diff=false,
    show_hessian_diff=false,
    test_equality=true,
    atol=1e-5,
    rtol=1e-5
)</code></pre><p>Test an objective&#39;s gradient and Hessian implementations against finite differences.</p><p>Similar to <code>test_integrator</code>, this validates that computed derivatives match finite differences.</p><p><strong>Arguments</strong></p><ul><li><code>obj::AbstractObjective</code>: The objective to test</li><li><code>traj::NamedTrajectory</code>: Trajectory defining the problem structure</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>show_gradient_diff</code>: Print element-wise differences in gradient</li><li><code>show_hessian_diff</code>: Print element-wise differences in Hessian</li><li><code>test_equality</code>: Test element-wise equality (vs. norm-based)</li><li><code>atol</code>: Absolute tolerance for comparisons</li><li><code>rtol</code>: Relative tolerance for comparisons</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/objectives/_objectives.jl#L230-L256">source</a></section></details></article><h2 id="Problems"><a class="docs-heading-anchor" href="#Problems">Problems</a><a id="Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Problems" title="Permalink"></a></h2><article><details class="docstring"><summary id="DirectTrajOpt.Problems.DirectTrajOptProblem"><a class="docstring-binding" href="#DirectTrajOpt.Problems.DirectTrajOptProblem"><code>DirectTrajOpt.Problems.DirectTrajOptProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct DirectTrajOptProblem</code></pre><p>A direct trajectory optimization problem containing all information needed for setup and solution.</p><p><strong>Fields</strong></p><ul><li><code>trajectory::NamedTrajectory</code>: The trajectory containing optimization variables and data</li><li><code>objective::AbstractObjective</code>: The objective function to minimize</li><li><code>integrators::Vector{&lt;:AbstractIntegrator}</code>: The integrators defining system dynamics</li><li><code>constraints::Vector{&lt;:AbstractConstraint}</code>: Constraints on the trajectory</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">DirectTrajOptProblem(
    traj::NamedTrajectory,
    obj::AbstractObjective,
    integrators::Vector{&lt;:AbstractIntegrator};
    constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]
)</code></pre><p>Create a problem from a trajectory, objective, and integrators. Trajectory constraints (initial, final, bounds) are automatically extracted and added to the constraint list. The dynamics object is created by the evaluator at solve time.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">traj = NamedTrajectory((x = rand(2, 10), u = rand(1, 10)), timestep=:Δt)
obj = QuadraticRegularizer(:u, traj, 1.0)
integrator = BilinearIntegrator(G, :x, :u)
prob = DirectTrajOptProblem(traj, obj, integrator)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/problems.jl#L17-L49">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Problems.get_trajectory_constraints-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.Problems.get_trajectory_constraints-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.Problems.get_trajectory_constraints</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_trajectory_constraints(traj::NamedTrajectory)</code></pre><p>Extract and create constraints from a NamedTrajectory&#39;s initial, final, and bounds specifications.</p><p><strong>Arguments</strong></p><ul><li><code>traj::NamedTrajectory</code>: Trajectory with specified initial conditions, final conditions, and/or bounds</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{AbstractConstraint}</code>: Vector of constraints including:<ul><li>Initial value equality constraints (from <code>traj.initial</code>)</li><li>Final value equality constraints (from <code>traj.final</code>)</li><li>Bounds constraints (from <code>traj.bounds</code>)</li></ul></li></ul><p><strong>Details</strong></p><p>The function automatically handles time indices based on which constraints are specified:</p><ul><li>If both initial and final constraints exist for a component, bounds apply to interior points (2:N-1)</li><li>If only initial exists, bounds apply from second point onward (2:N)</li><li>If only final exists, bounds apply up to second-to-last point (1:N-1)</li><li>If neither exist, bounds apply to all time points (1:N)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/problems.jl#L134-L154">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Problems.show_problem_details-Tuple{IO, DirectTrajOptProblem}"><a class="docstring-binding" href="#DirectTrajOpt.Problems.show_problem_details-Tuple{IO, DirectTrajOptProblem}"><code>DirectTrajOpt.Problems.show_problem_details</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">show_problem_details(io::IO, prob::DirectTrajOptProblem)</code></pre><p>Print the trajectory, objective, dynamics, and constraints sections of a problem.</p><p>This is used by both <code>DirectTrajOptProblem</code> and <code>QuantumControlProblem</code> display methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/problems.jl#L205-L211">source</a></section></details></article><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><h2 id="Ipopt-Solver"><a class="docs-heading-anchor" href="#Ipopt-Solver">Ipopt Solver</a><a id="Ipopt-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Ipopt-Solver" title="Permalink"></a></h2><article><details class="docstring"><summary id="DirectTrajOpt.IpoptSolverExt.IpoptEvaluator"><a class="docstring-binding" href="#DirectTrajOpt.IpoptSolverExt.IpoptEvaluator"><code>DirectTrajOpt.IpoptSolverExt.IpoptEvaluator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IpoptEvaluator &lt;: MOI.AbstractNLPEvaluator</code></pre><p>MathOptInterface NLP evaluator that bridges a <a href="#DirectTrajOpt.Problems.DirectTrajOptProblem"><code>DirectTrajOptProblem</code></a> to Ipopt.</p><p>Handles objective, gradient, constraint, Jacobian, and Hessian evaluation with pre-computed sparsity structures and linear index maps for efficient sparse matrix filling. Supports multi-threaded evaluation of independent integrators and constraints.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">IpoptEvaluator(prob::DirectTrajOptProblem; eval_hessian=true, verbose=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/solvers/ipopt_solver/evaluator.jl#L51-L65">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.IpoptSolverExt.IpoptOptions"><a class="docstring-binding" href="#DirectTrajOpt.IpoptSolverExt.IpoptOptions"><code>DirectTrajOpt.IpoptSolverExt.IpoptOptions</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IpoptOptions &lt;: AbstractSolverOptions</code></pre><p>Configuration options for the Ipopt nonlinear solver. All fields map directly to <a href="https://coin-or.github.io/Ipopt/OPTIONS.html">Ipopt options</a>.</p><p><strong>Commonly used fields</strong></p><ul><li><code>tol::Float64 = 1e-8</code>: Overall NLP convergence tolerance</li><li><code>max_iter::Int = 1_000</code>: Maximum number of solver iterations</li><li><code>max_cpu_time = 1_000_000.0</code>: Maximum CPU time in seconds</li><li><code>constr_viol_tol::Float64 = 1e-6</code>: Constraint violation tolerance</li><li><code>eval_hessian = true</code>: Whether to provide exact Hessians (false uses L-BFGS)</li><li><code>linear_solver = &quot;mumps&quot;</code>: Linear solver backend (<code>&quot;mumps&quot;</code>, <code>&quot;pardiso&quot;</code>, <code>&quot;ma27&quot;</code>, etc.)</li><li><code>print_level::Int = 5</code>: Ipopt output verbosity (0 = silent, 12 = maximum)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">opts = IpoptOptions(max_iter=200, tol=1e-6, print_level=0)
solve!(prob; options=opts)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/solvers/ipopt_solver/options.jl#L3-L23">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.IpoptSolverExt._fill_hessian_values!-Union{Tuple{T}, Tuple{AbstractVector{T}, IpoptEvaluator, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, T, AbstractVector{T}}} where T"><a class="docstring-binding" href="#DirectTrajOpt.IpoptSolverExt._fill_hessian_values!-Union{Tuple{T}, Tuple{AbstractVector{T}, IpoptEvaluator, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, T, AbstractVector{T}}} where T"><code>DirectTrajOpt.IpoptSolverExt._fill_hessian_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_fill_hessian_values!(H, evaluator, Z, σ, μ)</code></pre><p>Fill Hessian of Lagrangian values directly into output vector without building intermediate sparse matrices. Uses linear index map and direct SparseArrays access to eliminate allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/solvers/ipopt_solver/evaluator.jl#L488-L494">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.IpoptSolverExt._fill_jacobian_values!-Tuple{AbstractVector, IpoptEvaluator, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><a class="docstring-binding" href="#DirectTrajOpt.IpoptSolverExt._fill_jacobian_values!-Tuple{AbstractVector, IpoptEvaluator, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}"><code>DirectTrajOpt.IpoptSolverExt._fill_jacobian_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_fill_jacobian_values!(∂, evaluator, Z)</code></pre><p>Fill Jacobian values directly into the output vector without building intermediate sparse matrices. Uses pre-computed linear index map and direct SparseArrays access to eliminate allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/solvers/ipopt_solver/evaluator.jl#L419-L425">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.IpoptSolverExt._update_trajectory_cache!-Tuple{IpoptEvaluator, AbstractVector}"><a class="docstring-binding" href="#DirectTrajOpt.IpoptSolverExt._update_trajectory_cache!-Tuple{IpoptEvaluator, AbstractVector}"><code>DirectTrajOpt.IpoptSolverExt._update_trajectory_cache!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_update_trajectory_cache!(evaluator, Z⃗)</code></pre><p>Update the cached trajectory in-place with new data from Z⃗. Avoids repeated allocation of NamedTrajectory wrappers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/solvers/ipopt_solver/evaluator.jl#L396-L401">source</a></section></details></article><article><details class="docstring"><summary id="DirectTrajOpt.Solvers.solve!-Tuple{DirectTrajOptProblem}"><a class="docstring-binding" href="#DirectTrajOpt.Solvers.solve!-Tuple{DirectTrajOptProblem}"><code>DirectTrajOpt.Solvers.solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve!(
    prob::DirectTrajOptProblem;
    options::IpoptOptions=IpoptOptions(),
    max_iter::Int=options.max_iter,
    verbose::Bool=true,
    linear_solver::String=options.linear_solver,
    print_level::Int=options.print_level,
    callback=nothing
)</code></pre><p>Solve a direct trajectory optimization problem using Ipopt.</p><p><strong>Arguments</strong></p><ul><li><code>prob::DirectTrajOptProblem</code>: The trajectory optimization problem to solve.</li><li><code>options::IpoptOptions</code>: Ipopt solver options. Default is <code>IpoptOptions()</code>.</li><li><code>max_iter::Int</code>: Maximum number of iterations for the optimization solver.</li><li><code>verbose::Bool</code>: If <code>true</code>, print solver progress information.</li><li><code>linear_solver::String</code>: Linear solver to use (e.g., &quot;mumps&quot;, &quot;pardiso&quot;, &quot;ma27&quot;, &quot;ma57&quot;, &quot;ma77&quot;, &quot;ma86&quot;, &quot;ma97&quot;).</li><li><code>print_level::Int</code>: Ipopt print level (0-12). Higher values provide more detailed output.</li><li><code>callback::Function</code>: Optional callback function to execute during optimization.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: The problem&#39;s trajectory is updated in place with the optimized solution.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">prob = DirectTrajOptProblem(trajectory, objective, dynamics)
solve!(prob; max_iter=100, verbose=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/DirectTrajOpt.jl/blob/ddcc7b03d137741d56606beaa56ce5243bf7ba17/src/solvers/ipopt_solver/solver.jl#L13-L43">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/tutorials/minimum_time/">« Minimum Time</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 17:38">Wednesday 25 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
